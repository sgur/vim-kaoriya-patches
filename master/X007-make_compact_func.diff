# HG changeset patch
# Parent 3e84e9c2c249355bdf1e51643255eda5a9e519b0
Make compact stored functions (skeleton)

diff --git a/src/eval.c b/src/eval.c
index f03c786..bc8bd65 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -529,6 +529,8 @@ static void f_char2nr(typval_T *argvars, typval_T *rettv);
 static void f_cindent(typval_T *argvars, typval_T *rettv);
 static void f_clearmatches(typval_T *argvars, typval_T *rettv);
 static void f_col(typval_T *argvars, typval_T *rettv);
+static void f_compactinfo(typval_T *argvars, typval_T *rettv);
+static void f_compactreset(typval_T *argvars, typval_T *rettv);
 #if defined(FEAT_INS_EXPAND)
 static void f_complete(typval_T *argvars, typval_T *rettv);
 static void f_complete_add(typval_T *argvars, typval_T *rettv);
@@ -8409,6 +8411,8 @@ static struct fst
     {"cindent",		1, 1, f_cindent},
     {"clearmatches",	0, 0, f_clearmatches},
     {"col",		1, 1, f_col},
+    {"compactinfo",	0, 0, f_compactinfo},
+    {"compactreset",	0, 0, f_compactreset},
 #if defined(FEAT_INS_EXPAND)
     {"complete",	2, 2, f_complete},
     {"complete_add",	1, 1, f_complete_add},
@@ -10627,6 +10631,40 @@ f_col(typval_T *argvars, typval_T *rettv)
     rettv->vval.v_number = col;
 }
 
+/*
+ * "compactinfo()" function
+ */
+    static void
+f_compactinfo(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    list_T	*l;
+
+    if (rettv_list_alloc(rettv) == OK)
+    {
+	l = rettv->vval.v_list;
+	list_append_number(l, devel_compact_presize);
+	list_append_number(l, devel_compact_postsize);
+	list_append_number(l, devel_compact_funcnum);
+    }
+    else
+	rettv->vval.v_number = FALSE;
+}
+
+/*
+ * "compactreset()" function
+ */
+    static void
+f_compactreset(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv UNUSED;
+{
+    devel_compact_presize = 0;
+    devel_compact_postsize = 0;
+    devel_compact_funcnum = 0;
+}
+
 #if defined(FEAT_INS_EXPAND)
 /*
  * "complete()" function
@@ -23835,6 +23873,26 @@ find_option_end(char_u **arg, int *opt_flags)
     return p;
 }
 
+    static char_u *
+make_line_compact(line, prevline, lines, alloced)
+    char_u	*line;
+    char_u	**prevline;
+    garray_T	*lines;
+    int		*alloced;
+{
+    char_u	*p = skipwhite(line);
+
+    /* Substitute an empty line for a comment line. */
+    if (*p == '"')
+	return line + (int)STRLEN(line);
+    /* Remove leading whites. */
+    if (p != line)
+	return p;
+
+    /* Use original line. */
+    return NULL;
+}
+
 /*
  * ":function"
  */
@@ -23868,6 +23926,8 @@ ex_function(exarg_T *eap)
     int		todo;
     hashitem_T	*hi;
     int		sourcing_lnum_off;
+    int		compacted_size = 0;
+    char_u	*compacted_prevline = NULL;
 
     /*
      * ":function" without argument: list functions.
@@ -24304,6 +24364,37 @@ ex_function(exarg_T *eap)
 	    }
 	}
 
+	/* make theline compact. */
+	{
+	    char_u* compacted = NULL;
+	    int alloced = 0;
+
+	    if (p_cfs)
+	    {
+		compacted = make_line_compact(theline,
+		    &compacted_prevline, &newlines, &alloced);
+	    }
+
+	    if (compacted && compacted != theline)
+	    {
+		int sz1 = (int)STRLEN(theline);
+		int sz2 = (int)STRLEN(compacted);
+		assert(sz2 < sz1);
+		devel_compact_presize += sz1;
+		devel_compact_postsize += sz2;
+		mch_memmove(theline, compacted, sz2 + 1);
+	    }
+	    else
+	    {
+		int sz = (int)STRLEN(theline);
+		devel_compact_presize += sz;
+		devel_compact_postsize += sz;
+	    }
+
+	    if (compacted && alloced)
+		vim_free(compacted);
+	}
+
 	/* Add the line to the function. */
 	if (ga_grow(&newlines, 1 + sourcing_lnum_off) == FAIL)
 	{
@@ -24324,6 +24415,7 @@ ex_function(exarg_T *eap)
 	}
 
 	((char_u **)(newlines.ga_data))[newlines.ga_len++] = theline;
+	compacted_prevline = theline;
 
 	/* Add NULL lines for continuation lines, so that the line count is
 	 * equal to the index in the growarray.   */
@@ -24475,6 +24567,7 @@ ex_function(exarg_T *eap)
 	    goto erret;
 	}
     }
+    devel_compact_funcnum += 1;
     fp->uf_args = newargs;
     fp->uf_lines = newlines;
 #ifdef FEAT_PROFILE
diff --git a/src/globals.h b/src/globals.h
index 5010cd4..c288945 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -232,6 +232,9 @@ EXTERN int	debug_break_level INIT(= -1);	/* break below this level */
 EXTERN int	debug_did_msg INIT(= FALSE);	/* did "debug mode" message */
 EXTERN int	debug_tick INIT(= 0);		/* breakpoint change count */
 EXTERN int	debug_backtrace_level INIT(= 0); /* breakpoint backtrace level */
+EXTERN int	devel_compact_presize INIT(= 0);
+EXTERN int	devel_compact_postsize INIT(= 0);
+EXTERN int	devel_compact_funcnum INIT(= 0);
 # ifdef FEAT_PROFILE
 EXTERN int	do_profiling INIT(= PROF_NONE);	/* PROF_ values */
 # endif
diff --git a/src/option.c b/src/option.c
index fdea493..5fad03c 100644
--- a/src/option.c
+++ b/src/option.c
@@ -823,6 +823,15 @@ static struct vimoption options[] =
 			    SCRIPTID_INIT},
 			    /* P_PRI_MKRC isn't needed here, optval_default()
 			     * always returns TRUE for 'compatible' */
+    {"compact",  "cfs",	    P_BOOL|P_VIM,
+#ifdef FEAT_EVAL
+			    (char_u *)&p_cfs, PV_NONE,
+			    {(char_u *)TRUE, (char_u *)FALSE}
+#else
+			    (char_u *)&NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
     {"compatible",  "cp",   P_BOOL|P_RALL,
 			    (char_u *)&p_cp, PV_NONE,
 			    {(char_u *)TRUE, (char_u *)FALSE} SCRIPTID_INIT},
diff --git a/src/option.h b/src/option.h
index 0340066..e19d39b 100644
--- a/src/option.h
+++ b/src/option.h
@@ -418,6 +418,9 @@ EXTERN long	p_ch;		/* 'cmdheight' */
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 EXTERN int	p_confirm;	/* 'confirm' */
 #endif
+#ifdef FEAT_EVAL
+EXTERN int	p_cfs;		/* 'compactfunc' */
+#endif
 EXTERN int	p_cp;		/* 'compatible' */
 #ifdef FEAT_INS_EXPAND
 EXTERN char_u	*p_cot;		/* 'completeopt' */
