diff --git a/Filelist b/Filelist
index 1b70cf2..be63d90 100644
--- a/Filelist
+++ b/Filelist
@@ -16,6 +16,7 @@ SRC_ALL =	\
 		src/buffer.c \
 		src/channel.c \
 		src/charset.c \
+		src/clpum.c \
 		src/crypt.c \
 		src/crypt_zip.c \
 		src/diff.c \
@@ -121,6 +122,7 @@ SRC_ALL =	\
 		src/proto/buffer.pro \
 		src/proto/channel.pro \
 		src/proto/charset.pro \
+		src/proto/clpum.pro \
 		src/proto/crypt.pro \
 		src/proto/crypt_zip.pro \
 		src/proto/diff.pro \
diff --git a/runtime/doc/eval.txt b/runtime/doc/eval.txt
index 4b55f91..baa4b50 100644
--- a/runtime/doc/eval.txt
+++ b/runtime/doc/eval.txt
@@ -7820,6 +7820,7 @@ byte_offset		Compiled with support for 'o' in 'statusline'
 cindent			Compiled with 'cindent' support.
 clientserver		Compiled with remote invocation support |clientserver|.
 clipboard		Compiled with 'clipboard' support.
+clpum			Compiled with command line popup menu support.
 cmdline_compl		Compiled with |cmdline-completion| support.
 cmdline_hist		Compiled with |cmdline-history| support.
 cmdline_info		Compiled with 'showcmd' and 'ruler' support.
diff --git a/runtime/doc/options.txt b/runtime/doc/options.txt
index 98017ec..27d85f1 100644
--- a/runtime/doc/options.txt
+++ b/runtime/doc/options.txt
@@ -1619,6 +1619,44 @@ A jump table for the options with a short description can be found at |Q_op|.
 			The rest of the option value will be used for
 			{pattern}, this must be the last entry.
 
+						*'clcompletefunc'* *'clcfu'*
+'clcompletefunc' 'clcfu'	string	(default: empty)
+			global
+			{not in Vi}
+			{not available when compiled without the |+eval|
+			or |+cmdline_compl| features}
+	This option specifies a function to be used for Command-line mode
+	completion with CTRL-X. |c_CTRL-X|
+	See |complete-functions| for an explanation of how the function is
+	invoked and what it should return.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
+
+						*'clcompleteopt'* *'clcot'*
+'clcompleteopt' 'clcot'	string	(default: "menuone,noinsert")
+			global
+			{not available when compiled without the
+			|+cmdline_compl| feature}
+			{not in Vi}
+	A comma separated list of options for Command-line mode completion
+	|cmdline-completion|.  The supported values are:
+
+	   menu	    Use a popup menu to show the possible completions.  The
+		    menu is only shown when there is more than one match and
+		    sufficient colors are available.  |ins-completion-menu|
+
+	   menuone  Use the popup menu also when there is only one match.
+		    Useful when there is additional information about the
+		    match, e.g., what file it comes from.
+
+	   noinsert Do not insert any text for a match until the user selects
+		    a match from the menu. Only works in combination with
+		    "menu" or "menuone". No effect if "longest" is present.
+
+	   noselect Do not select a match in the menu, force the user to
+		    select one from the menu. Only works in combination with
+		    "menu" or "menuone".
+
 						*'cmdheight'* *'ch'*
 'cmdheight' 'ch'	number	(default 1)
 			global
@@ -8433,12 +8471,21 @@ A jump table for the options with a short description can be found at |Q_op|.
 	"list:longest"	When more than one match, list all matches and
 			complete till longest common string.
 	When there is only a single match, it is fully completed in all cases.
+	If you compiled with |+clpum| feature, you can use following value.
+	"popup"		When 'wildmenu' is enabled, complete part of a keyword
+			or line that has been typed.
+
+	Can not be mixed "full" and "popup".  The later value is ignored.
 
 	Examples: >
 		:set wildmode=full
 <	Complete first full match, next match, etc.  (the default) >
+		:set wildmode=popup
+<	Complete full match using popup menu >
 		:set wildmode=longest,full
 <	Complete longest common string, then each full match >
+		:set wildmode=longest,popup
+<	Complete longest common string, then each full match using popup menu >
 		:set wildmode=list:full
 <	List all matches and complete each full match >
 		:set wildmode=list,full
diff --git a/runtime/doc/various.txt b/runtime/doc/various.txt
index 31f1a1b..6e8248a 100644
--- a/runtime/doc/various.txt
+++ b/runtime/doc/various.txt
@@ -319,6 +319,7 @@ m  *+channel*		inter process communication |channel|
 N  *+cindent*		|'cindent'|, C indenting
 N  *+clientserver*	Unix and Win32: Remote invocation |clientserver|
    *+clipboard*		|clipboard| support
+N  *+clpum*		command line pupup menu support.
 N  *+cmdline_compl*	command line completion |cmdline-completion|
 N  *+cmdline_hist*	command line history |cmdline-history|
 N  *+cmdline_info*	|'showcmd'| and |'ruler'|
diff --git a/src/Make_bc5.mak b/src/Make_bc5.mak
index 3a11c8f..22308e8 100644
--- a/src/Make_bc5.mak
+++ b/src/Make_bc5.mak
@@ -541,6 +541,7 @@ vimobj =  \
 	$(OBJDIR)\blowfish.obj \
 	$(OBJDIR)\buffer.obj \
 	$(OBJDIR)\charset.obj \
+	$(OBJDIR)\clpum.obj \
 	$(OBJDIR)\crypt.obj \
 	$(OBJDIR)\crypt_zip.obj \
 	$(OBJDIR)\diff.obj \
diff --git a/src/Make_cyg_ming.mak b/src/Make_cyg_ming.mak
index 005df19..82279d3 100644
--- a/src/Make_cyg_ming.mak
+++ b/src/Make_cyg_ming.mak
@@ -598,6 +598,7 @@ OBJ = \
 	$(OUTDIR)/blowfish.o \
 	$(OUTDIR)/buffer.o \
 	$(OUTDIR)/charset.o \
+	$(OUTDIR)/clpum.o \
 	$(OUTDIR)/crypt.o \
 	$(OUTDIR)/crypt_zip.o \
 	$(OUTDIR)/diff.o \
diff --git a/src/Make_dice.mak b/src/Make_dice.mak
index 708fdfb..113b77f 100644
--- a/src/Make_dice.mak
+++ b/src/Make_dice.mak
@@ -30,6 +30,7 @@ SRC = \
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	clpum.c \
 	crypt.c \
 	crypt_zip.c \
 	diff.c \
@@ -81,6 +82,7 @@ OBJ =	o/arabic.o \
 	o/blowfish.o \
 	o/buffer.o \
 	o/charset.o \
+	o/clpum.o \
 	o/crypt.o \
 	o/crypt_zip.o \
 	o/diff.o \
@@ -155,6 +157,8 @@ o/buffer.o:	buffer.c  $(SYMS)
 
 o/charset.o:	charset.c  $(SYMS)
 
+o/clpum.o:	clpum.c  $(SYMS)
+
 o/crypt.o:	crypt.c  $(SYMS)
 
 o/crypt_zip.o:	crypt_zip.c  $(SYMS)
diff --git a/src/Make_ivc.mak b/src/Make_ivc.mak
index f3251c3..3c2ab09 100644
--- a/src/Make_ivc.mak
+++ b/src/Make_ivc.mak
@@ -214,6 +214,7 @@ LINK32_OBJS= \
 	"$(INTDIR)/blowfish.obj" \
 	"$(INTDIR)/buffer.obj" \
 	"$(INTDIR)/charset.obj" \
+	"$(INTDIR)/clpum.obj" \
 	"$(INTDIR)/crypt.obj" \
 	"$(INTDIR)/crypt_zip.obj" \
 	"$(INTDIR)/diff.obj" \
@@ -348,6 +349,10 @@ SOURCE=.\charset.c
 # End Source File
 # Begin Source File
 
+SOURCE=.\clpum.c
+# End Source File
+# Begin Source File
+
 SOURCE=.\crypt.c
 # End Source File
 # Begin Source File
diff --git a/src/Make_manx.mak b/src/Make_manx.mak
index 38fef56..5acf0d6 100644
--- a/src/Make_manx.mak
+++ b/src/Make_manx.mak
@@ -40,6 +40,7 @@ SRC =	arabic.c \
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	clpum.c \
 	crypt.c \
 	crypt_zip.c \
 	diff.c \
@@ -93,6 +94,7 @@ OBJ =	obj/arabic.o \
 	obj/blowfish.o \
 	obj/buffer.o \
 	obj/charset.o \
+	obj/clpum.o \
 	obj/crypt.o \
 	obj/crypt_zip.o \
 	obj/diff.o \
@@ -144,6 +146,7 @@ PRO =	proto/arabic.pro \
 	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/clpum.pro \
 	proto/crypt.pro \
 	proto/crypt_zip.pro \
 	proto/diff.pro \
@@ -247,6 +250,9 @@ obj/buffer.o:	buffer.c
 obj/charset.o:	charset.c
 	$(CCSYM) $@ charset.c
 
+obj/clpum.o:	clpum.c
+	$(CCSYM) $@ clpum.c
+
 obj/crypt.o:	crypt.c
 	$(CCSYM) $@ crypt.c
 
diff --git a/src/Make_morph.mak b/src/Make_morph.mak
index 33342eb..a4e1134 100644
--- a/src/Make_morph.mak
+++ b/src/Make_morph.mak
@@ -28,6 +28,7 @@ SRC =	arabic.c						\
 	blowfish.c						\
 	buffer.c						\
 	charset.c						\
+	clpum.c							\
 	crypt.c							\
 	crypt_zip.c						\
 	diff.c							\
diff --git a/src/Make_mvc.mak b/src/Make_mvc.mak
index dc27809..d0f48fc 100644
--- a/src/Make_mvc.mak
+++ b/src/Make_mvc.mak
@@ -552,6 +552,7 @@ OBJ = \
 	$(OUTDIR)\blowfish.obj \
 	$(OUTDIR)\buffer.obj \
 	$(OUTDIR)\charset.obj \
+	$(OUTDIR)\clpum.obj \
 	$(OUTDIR)\crypt.obj \
 	$(OUTDIR)\crypt_zip.obj \
 	$(OUTDIR)\diff.obj \
@@ -1158,6 +1159,8 @@ $(OUTDIR)/buffer.obj:	$(OUTDIR) buffer.c  $(INCL)
 
 $(OUTDIR)/charset.obj:	$(OUTDIR) charset.c  $(INCL)
 
+$(OUTDIR)/clpum.obj:	$(OUTDIR) clpum.c  $(INCL)
+
 $(OUTDIR)/crypt.obj:	$(OUTDIR) crypt.c  $(INCL)
 
 $(OUTDIR)/crypt_zip.obj: $(OUTDIR) crypt_zip.c  $(INCL)
@@ -1356,6 +1359,7 @@ proto.h: \
 	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/clpum.pro \
 	proto/crypt.pro \
 	proto/crypt_zip.pro \
 	proto/diff.pro \
diff --git a/src/Make_sas.mak b/src/Make_sas.mak
index 6ebd7d0..ad032e0 100644
--- a/src/Make_sas.mak
+++ b/src/Make_sas.mak
@@ -93,6 +93,7 @@ SRC = \
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	clpum.c \
 	crypt.c \
 	crypt_zip.c \
 	diff.c \
@@ -145,6 +146,7 @@ OBJ = \
 	blowfish.o \
 	buffer.o \
 	charset.o \
+	clpum.o \
 	crypt.o \
 	crypt_zip.o \
 	diff.o \
@@ -197,6 +199,7 @@ PRO = \
 	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/clpum.pro \
 	proto/crypt.pro \
 	proto/crypt_zip.pro \
 	proto/diff.pro \
@@ -307,6 +310,7 @@ buffer.o:		buffer.c
 proto/buffer.pro:	buffer.c
 charset.o:		charset.c
 proto/charset.pro:	charset.c
+clpum.o:		clpum.c
 crypt.o:		crypt.c
 proto/crypt.pro:	crypt.c
 crypt_zip.o:		crypt_zip.c
diff --git a/src/Make_vms.mms b/src/Make_vms.mms
index 4ddb8a1..af5b218 100644
--- a/src/Make_vms.mms
+++ b/src/Make_vms.mms
@@ -299,7 +299,7 @@ ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
 ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
 	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
 
-SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
+SRC =	arabic.c blowfish.c buffer.c charset.c clpum.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
 	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c farsi.c fileio.c fold.c getchar.c \
 	hardcopy.c hashtab.c json.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
 	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
@@ -308,7 +308,7 @@ SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph
 	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
 	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
 
-OBJ =	arabic.obj blowfish.obj buffer.obj charset.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
+OBJ =	arabic.obj blowfish.obj buffer.obj charset.obj clpum.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
 	ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj \
 	if_xcmdsrv.obj farsi.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj json.obj main.obj mark.obj \
 	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
@@ -496,6 +496,10 @@ charset.obj : charset.c vim.h [.auto]config.h feature.h os_unix.h \
  ascii.h keymap.h term.h macros.h structs.h regexp.h \
  gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
  globals.h farsi.h arabic.h
+clpum.obj : clpum.c vim.h [.auto]config.h feature.h os_unix.h \
+ ascii.h keymap.h term.h macros.h structs.h regexp.h \
+ gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
+ globals.h farsi.h arabic.h
 diff.obj : diff.c vim.h [.auto]config.h feature.h os_unix.h   \
  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
  [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
diff --git a/src/Makefile b/src/Makefile
index 13bf776..65e9ec3 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1482,6 +1482,7 @@ BASIC_SRC = \
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	clpum.c \
 	crypt.c \
 	crypt_zip.c \
 	diff.c \
@@ -1581,6 +1582,7 @@ OBJ_COMMON = \
 	objects/buffer.o \
 	objects/blowfish.o \
 	objects/charset.o \
+	objects/clpum.o \
 	objects/crypt.o \
 	objects/crypt_zip.o \
 	objects/diff.o \
@@ -1660,6 +1662,7 @@ PRO_AUTO = \
 	blowfish.pro \
 	buffer.pro \
 	charset.pro \
+	clpum.pro \
 	crypt.pro \
 	crypt_zip.pro \
 	diff.pro \
@@ -2020,6 +2023,7 @@ test_arglist \
 	test_backspace_opt \
 	test_cdo \
 	test_channel \
+	test_clpum \
 	test_cmdline \
 	test_cursor_func \
 	test_delete \
@@ -2770,6 +2774,9 @@ objects/buffer.o: buffer.c
 objects/charset.o: charset.c
 	$(CCC) -o $@ charset.c
 
+objects/clpum.o: clpum.c
+	$(CCC) -o $@ clpum.c
+
 objects/crypt.o: crypt.c
 	$(CCC) -o $@ crypt.c
 
@@ -3141,6 +3148,10 @@ objects/charset.o: charset.c vim.h auto/config.h feature.h os_unix.h auto/osdef.
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h globals.h \
  farsi.h arabic.h
+objects/clpum.o: clpum.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+ gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h globals.h \
+ farsi.h arabic.h
 objects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h globals.h \
diff --git a/src/clpum.c b/src/clpum.c
new file mode 100644
index 0000000..adebd6b
--- /dev/null
+++ b/src/clpum.c
@@ -0,0 +1,434 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * clpum.c: Command-line popup menu (CLPUM)
+ */
+#include "vim.h"
+
+#if defined(FEAT_CLPUM) || defined(PROTO)
+
+static pumitem_T *clpum_array = NULL;	/* items of displayed pum */
+static int clpum_size = -1;		/* nr of items in "clpum_array" */
+static int clpum_selected;		/* index of selected item or -1 */
+static int clpum_first = 0;		/* index of top item */
+
+static int clpum_height;			/* nr of displayed pum items */
+static int clpum_width;			/* width of displayed pum items */
+static int clpum_base_width;		/* width of pum items base */
+static int clpum_kind_width;		/* width of pum items kind column */
+static int clpum_scrollbar;		/* TRUE when scrollbar present */
+
+static int clpum_row;			/* top row of pum */
+static int clpum_col;			/* left column of pum */
+
+static int clpum_do_redraw = FALSE;	/* do redraw anyway */
+
+static int clpum_set_selected(int n, int repeat);
+
+#define CLPUM_DEF_HEIGHT 10
+#define CLPUM_DEF_WIDTH  15
+
+/*
+ * Show the popup menu with items "array[size]".
+ * "array" must remain valid until clpum_undisplay() is called!
+ * When possible the leftmost character is aligned with screen column "col".
+ * The menu appears above the screen line "row" or at "row" + "height" - 1.
+ */
+    void
+clpum_display(
+    pumitem_T	*array,
+    int		size,
+    int		selected,	/* index of initially selected item, none if
+				   out of range */
+    int		disp_col)
+{
+    int		w;
+    int		def_width;
+    int		max_width;
+    int		kind_width;
+    int		extra_width;
+    int		i;
+    int		row;
+    int		col;
+    int		redo_count = 0;
+
+redo:
+    def_width = CLPUM_DEF_WIDTH;
+    max_width = 0;
+    kind_width = 0;
+    extra_width = 0;
+
+    /* Pretend the pum is already there to avoid that must_redraw is set when
+     * 'cuc' is on. */
+    clpum_array = (pumitem_T *)1;
+    validate_cursor_col();
+    clpum_array = NULL;
+
+    row = cmdline_row;
+
+    /*
+     * Figure out the size and position of the pum.
+     */
+    if (size < CLPUM_DEF_HEIGHT)
+	clpum_height = size;
+    else
+	clpum_height = CLPUM_DEF_HEIGHT;
+    if (p_clph > 0 && clpum_height > p_clph)
+	clpum_height = p_clph;
+
+    /* pum above "row" */
+
+    if (row >= size)
+    {
+	clpum_row = row - size;
+	clpum_height = size;
+    }
+    else
+    {
+	clpum_row = 0;
+	clpum_height = row;
+    }
+    if (p_clph > 0 && clpum_height > p_clph)
+    {
+	clpum_row += clpum_height - p_clph;
+	clpum_height = p_clph;
+    }
+
+    /* don't display when we only have room for one line */
+    if (clpum_height < 1 || (clpum_height == 1 && size > 1))
+	return;
+
+    /* Compute the width of the widest match and the widest extra. */
+    for (i = 0; i < size; ++i)
+    {
+	w = vim_strsize(array[i].pum_text);
+	if (max_width < w)
+	    max_width = w;
+	if (array[i].pum_kind != NULL)
+	{
+	    w = vim_strsize(array[i].pum_kind) + 1;
+	    if (kind_width < w)
+		kind_width = w;
+	}
+	if (array[i].pum_extra != NULL)
+	{
+	    w = vim_strsize(array[i].pum_extra) + 1;
+	    if (extra_width < w)
+		extra_width = w;
+	}
+    }
+    clpum_base_width = max_width;
+    clpum_kind_width = kind_width;
+
+    col = disp_col;
+
+    /* if there are more items than room we need a scrollbar */
+    if (clpum_height < size)
+    {
+	clpum_scrollbar = 1;
+	++max_width;
+    }
+    else
+	clpum_scrollbar = 0;
+
+    if (def_width < max_width)
+	def_width = max_width;
+
+    if (col < Columns - CLPUM_DEF_WIDTH || col < Columns - max_width)
+    {
+	/* align pum column with "col" */
+	clpum_col = col;
+
+	clpum_width = Columns - clpum_col - clpum_scrollbar;
+
+	if (clpum_width > max_width + kind_width + extra_width + 1
+					    && clpum_width > CLPUM_DEF_WIDTH)
+	{
+	    clpum_width = max_width + kind_width + extra_width + 1;
+	    if (clpum_width < CLPUM_DEF_WIDTH)
+		clpum_width = CLPUM_DEF_WIDTH;
+	}
+    }
+    else if (Columns < def_width)
+    {
+	/* not enough room, will use what we have */
+	clpum_col = 0;
+	clpum_width = Columns - 1;
+    }
+    else
+    {
+	if (max_width > CLPUM_DEF_WIDTH)
+	    max_width = CLPUM_DEF_WIDTH;	/* truncate */
+	clpum_col = Columns - max_width;
+	clpum_width = max_width - clpum_scrollbar;
+    }
+
+    clpum_array = array;
+    clpum_size = size;
+
+    /* Set selected item and redraw.  If the window size changed need to redo
+     * the positioning.  Limit this to two times, when there is not much
+     * room the window size will keep changing. */
+    if (clpum_set_selected(selected, redo_count) && ++redo_count <= 2)
+	goto redo;
+}
+
+/*
+ * Redraw the popup menu, using "clpum_first" and "clpum_selected".
+ */
+    void
+clpum_redraw(void)
+{
+    int		row = clpum_row;
+    int		col;
+    int		attr_norm = highlight_attr[HLF_CLPNI];
+    int		attr_select = highlight_attr[HLF_CLPSI];
+    int		attr_scroll = highlight_attr[HLF_CLPSB];
+    int		attr_thumb = highlight_attr[HLF_CLPST];
+    int		attr;
+    int		i;
+    int		idx;
+    char_u	*s;
+    char_u	*p = NULL;
+    int		totwidth, width, w;
+    int		thumb_pos = 0;
+    int		thumb_heigth = 1;
+    int		round;
+    int		n;
+
+    /* Never display more than we have */
+    if (clpum_first > clpum_size - clpum_height)
+	clpum_first = clpum_size - clpum_height;
+
+    if (clpum_scrollbar)
+    {
+	thumb_heigth = clpum_height * clpum_height / clpum_size;
+	if (thumb_heigth == 0)
+	    thumb_heigth = 1;
+	thumb_pos = (clpum_first * (clpum_height - thumb_heigth)
+			    + (clpum_size - clpum_height) / 2)
+						/ (clpum_size - clpum_height);
+    }
+
+    for (i = 0; i < clpum_height; ++i)
+    {
+	idx = i + clpum_first;
+	attr = (idx == clpum_selected) ? attr_select : attr_norm;
+
+	/* prepend a space if there is room */
+	if (clpum_col > 0)
+	    screen_putchar(' ', row, clpum_col - 1, attr);
+
+	/* Display each entry, use two spaces for a Tab.
+	 * Do this 3 times: For the main text, kind and extra info */
+	col = clpum_col;
+	totwidth = 0;
+	for (round = 1; round <= 3; ++round)
+	{
+	    width = 0;
+	    s = NULL;
+	    switch (round)
+	    {
+		case 1: p = clpum_array[idx].pum_text; break;
+		case 2: p = clpum_array[idx].pum_kind; break;
+		case 3: p = clpum_array[idx].pum_extra; break;
+	    }
+	    if (p != NULL)
+		for ( ; ; mb_ptr_adv(p))
+		{
+		    if (s == NULL)
+			s = p;
+		    w = ptr2cells(p);
+		    if (*p == NUL || *p == TAB || totwidth + w > clpum_width)
+		    {
+			/* Display the text that fits or comes before a Tab.
+			 * First convert it to printable characters. */
+			char_u	*st;
+			int	saved = *p;
+
+			*p = NUL;
+			st = transstr(s);
+			*p = saved;
+			if (st != NULL)
+			{
+			    screen_puts_len(st, (int)STRLEN(st), row, col,
+								    attr);
+			    vim_free(st);
+			}
+			col += width;
+
+			if (*p != TAB)
+			    break;
+
+			/* Display two spaces for a Tab. */
+			screen_puts_len((char_u *)"  ", 2, row, col, attr);
+			col += 2;
+			totwidth += 2;
+			s = NULL;	    /* start text at next char */
+			width = 0;
+		    }
+		    else
+			width += w;
+		}
+
+	    if (round > 1)
+		n = clpum_kind_width + 1;
+	    else
+		n = 1;
+
+	    /* Stop when there is nothing more to display. */
+	    if (round == 3
+		    || (round == 2 && clpum_array[idx].pum_extra == NULL)
+		    || (round == 1 && clpum_array[idx].pum_kind == NULL
+					  && clpum_array[idx].pum_extra == NULL)
+		    || clpum_base_width + n >= clpum_width)
+		break;
+	    screen_fill(row, row + 1, col, clpum_col + clpum_base_width + n,
+							    ' ', ' ', attr);
+	    col = clpum_col + clpum_base_width + n;
+	    totwidth = clpum_base_width + n;
+	}
+
+	screen_fill(row, row + 1, col, clpum_col + clpum_width, ' ', ' ',
+									attr);
+	if (clpum_scrollbar > 0)
+	{
+	    screen_putchar(' ', row, clpum_col + clpum_width,
+		    i >= thumb_pos && i < thumb_pos + thumb_heigth
+						? attr_thumb : attr_scroll);
+	}
+
+	++row;
+    }
+}
+
+/*
+ * Set the index of the currently selected item.  The menu will scroll when
+ * necessary.  When "n" is out of range don't scroll.
+ * This may be repeated when the preview window is used:
+ * "repeat" == 0: open preview window normally
+ * "repeat" == 1: open preview window but don't set the size
+ * "repeat" == 2: don't open preview window
+ * Returns TRUE when the window was resized and the location of the popup menu
+ * must be recomputed.
+ */
+    static int
+clpum_set_selected(
+    int	    n,
+    int	    repeat UNUSED)
+{
+    int	    resized = FALSE;
+    int	    context = clpum_height / 2;
+
+    clpum_selected = n;
+
+    if (clpum_selected >= 0 && clpum_selected < clpum_size)
+    {
+	if (clpum_first > clpum_selected - 4)
+	{
+	    /* scroll down; when we did a jump it's probably a PageUp then
+	     * scroll a whole page */
+	    if (clpum_first > clpum_selected - 2)
+	    {
+		clpum_first -= clpum_height - 2;
+		if (clpum_first < 0)
+		    clpum_first = 0;
+		else if (clpum_first > clpum_selected)
+		    clpum_first = clpum_selected;
+	    }
+	    else
+		clpum_first = clpum_selected;
+	}
+	else if (clpum_first < clpum_selected - clpum_height + 5)
+	{
+	    /* scroll up; when we did a jump it's probably a PageDown then
+	     * scroll a whole page */
+	    if (clpum_first < clpum_selected - clpum_height + 1 + 2)
+	    {
+		clpum_first += clpum_height - 2;
+		if (clpum_first < clpum_selected - clpum_height + 1)
+		    clpum_first = clpum_selected - clpum_height + 1;
+	    }
+	    else
+		clpum_first = clpum_selected - clpum_height + 1;
+	}
+
+	/* Give a few lines of context when possible. */
+	if (context > 3)
+	    context = 3;
+	if (clpum_height > 2)
+	{
+	    if (clpum_first > clpum_selected - context)
+	    {
+		/* scroll down */
+		clpum_first = clpum_selected - context;
+		if (clpum_first < 0)
+		    clpum_first = 0;
+	    }
+	    else if (clpum_first < clpum_selected + context - clpum_height + 1)
+	    {
+		/* scroll up */
+		clpum_first = clpum_selected + context - clpum_height + 1;
+	    }
+	}
+    }
+
+    if (!resized)
+	clpum_redraw();
+
+    return resized;
+}
+
+/*
+ * Undisplay the popup menu (later).
+ */
+    void
+clpum_undisplay(void)
+{
+    //FreeWild(clpum_size, clpum_array);
+    clpum_array = NULL;
+    //clpum_size = -1;
+    redraw_all_later(SOME_VALID);
+#ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+#endif
+    status_redraw_all();
+}
+
+/*
+ * Clear the popup menu.  Currently only resets the offset to the first
+ * displayed item.
+ */
+    void
+clpum_clear(void)
+{
+    clpum_first = 0;
+}
+
+/*
+ * Return TRUE if the popup menu is displayed.
+ * Overruled when "clpum_do_redraw" is set, used to redraw the status lines.
+ */
+    int
+clpum_visible(void)
+{
+    return !clpum_do_redraw && clpum_array != NULL;
+}
+
+/*
+ * Return the height of the popup menu, the number of entries visible.
+ * Only valid when clpum_visible() returns TRUE!
+ */
+    int
+clpum_get_height(void)
+{
+    return clpum_height;
+}
+#endif
diff --git a/src/eval.c b/src/eval.c
index 4764f49..d79529b 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -379,6 +379,7 @@ static struct vimvar
     {VV_NAME("none",		 VAR_SPECIAL), VV_RO},
     {VV_NAME("vim_did_enter",	 VAR_NUMBER), VV_RO},
     {VV_NAME("testing",		 VAR_NUMBER), 0},
+    {VV_NAME("clcompleted_item", VAR_DICT), VV_RO},
 };
 
 /* shorthand */
@@ -532,6 +533,9 @@ static void f_changenr(typval_T *argvars, typval_T *rettv);
 static void f_char2nr(typval_T *argvars, typval_T *rettv);
 static void f_cindent(typval_T *argvars, typval_T *rettv);
 static void f_clearmatches(typval_T *argvars, typval_T *rettv);
+#ifdef FEAT_CLPUM
+static void f_clpumvisible(typval_T *argvars, typval_T *rettv);
+#endif
 static void f_col(typval_T *argvars, typval_T *rettv);
 #if defined(FEAT_INS_EXPAND)
 static void f_complete(typval_T *argvars, typval_T *rettv);
@@ -987,6 +991,7 @@ eval_init(void)
     set_vim_var_nr(VV_SEARCHFORWARD, 1L);
     set_vim_var_nr(VV_HLSEARCH, 1L);
     set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
+    set_vim_var_dict(VV_CLCOMPLETED_ITEM, dict_alloc());
     set_vim_var_list(VV_ERRORS, list_alloc());
 
     set_vim_var_nr(VV_FALSE, VVAL_FALSE);
@@ -8541,6 +8546,9 @@ static struct fst
     {"char2nr",		1, 2, f_char2nr},
     {"cindent",		1, 1, f_cindent},
     {"clearmatches",	0, 0, f_clearmatches},
+#ifdef FEAT_CLPUM
+    {"clpumvisible",	0, 0, f_clpumvisible},
+#endif
     {"col",		1, 1, f_col},
 #if defined(FEAT_INS_EXPAND)
     {"complete",	2, 2, f_complete},
@@ -10729,6 +10737,22 @@ f_clearmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
 #endif
 }
 
+#ifdef FEAT_CLPUM
+/*
+ * "clpumvisible()" function
+ */
+    static void
+f_clpumvisible(
+    typval_T	*argvars UNUSED,
+    typval_T	*rettv UNUSED)
+{
+    if (clpum_visible())
+	rettv->vval.v_number = 1;
+    else
+	rettv->vval.v_number = 0;
+}
+#endif
+
 /*
  * "col(string)" function
  */
@@ -14028,6 +14052,9 @@ f_has(typval_T *argvars, typval_T *rettv)
 #ifdef FEAT_CLIPBOARD
 	"clipboard",
 #endif
+#ifdef FEAT_CLPUM
+	"clpum",
+#endif
 #ifdef FEAT_CMDL_COMPL
 	"cmdline_compl",
 #endif
diff --git a/src/ex_getln.c b/src/ex_getln.c
index 36902e5..3095c50 100644
--- a/src/ex_getln.c
+++ b/src/ex_getln.c
@@ -83,6 +83,118 @@ static int	cmd_hkmap = 0;	/* Hebrew mapping during command line */
 static int	cmd_fkmap = 0;	/* Farsi mapping during command line */
 #endif
 
+#ifdef FEAT_CLPUM
+static char e_complwin[] = N_("E839: Completion function changed window");
+static char e_compldel[] = N_("E840: Completion function deleted text");
+
+/*
+ * Structure used to store one match for insert completion.
+ */
+typedef struct clpum_compl_S clpum_compl_T;
+struct clpum_compl_S
+{
+    clpum_compl_T	*cp_next;
+    clpum_compl_T	*cp_prev;
+    char_u	*cp_str;	/* matched text */
+    char	cp_icase;	/* TRUE or FALSE: ignore case */
+    char_u	*(cp_text[CPT_COUNT]);	/* text for the menu */
+    char_u	*cp_fname;	/* file containing the match, allocated when
+				 * cp_flags has FREE_FNAME */
+    int		cp_flags;	/* ORIGINAL_TEXT or FREE_FNAME */
+    int		cp_number;	/* sequence number */
+};
+
+#define ORIGINAL_TEXT	(1)   /* the original text when the expansion begun */
+#define FREE_FNAME	(2)
+
+/*
+ * All the current matches are stored in a list.
+ * "clpum_compl_first_match" points to the start of the list.
+ * "clpum_compl_curr_match" points to the currently selected entry.
+ * "clpum_compl_shown_match" is different from clpum_compl_curr_match during
+ * clpum_compl_get_exp().
+ */
+static clpum_compl_T    *clpum_compl_first_match = NULL;
+static clpum_compl_T    *clpum_compl_curr_match = NULL;
+static clpum_compl_T    *clpum_compl_shown_match = NULL;
+
+/* After using a cursor key <Enter> selects a match in the popup menu,
+ * otherwise it inserts a line break. */
+static int	  clpum_compl_enter_selects = FALSE;
+
+/* When "clpum_compl_leader" is not NULL only matches that start with this
+ * string are used. */
+static char_u	  *clpum_compl_leader = NULL;
+
+static int  clpum_compl_no_insert = TRUE;	/* noinsert candidate */
+static int  clpum_compl_no_select = FALSE;	/* noselect candidate */
+
+static int  clpum_compl_used_match;	/* Selected one of the matches.  When
+					   FALSE the match was edited. */
+
+static int  clpum_compl_was_interrupted = FALSE;  /* didn't finish finding
+						     completions. */
+
+static int  clpum_compl_restarting = FALSE;	/* don't insert match */
+
+/* When the first completion is done "clpum_compl_started" is set.  When it's
+ * FALSE the word to be completed must be located. */
+static int  clpum_compl_started = FALSE;
+
+/* Set when doing something for completion that may call edit() recursively,
+ * which is not allowed. */
+static int  clpum_compl_busy = FALSE;
+
+static int  clpum_compl_matches = 0;
+static char_u	*clpum_compl_pattern = NULL;
+static int  clpum_compl_direction = FORWARD;
+static int  clpum_compl_shows_dir = FORWARD;
+static int  clpum_compl_pending = 0;	    /* > 1 for postponed CTRL-N */
+static pos_T	clpum_compl_startpos;
+static colnr_T	clpum_compl_col = 0;	    /* column where the text starts
+					     * that is being completed */
+static char_u	*clpum_compl_orig_text = NULL;  /* text as it was before
+					     * completion started */
+static int  clpum_compl_cont_mode = 0;
+static expand_T	*clpum_compl_xp;
+
+static int  clpum_compl_opt_refresh_always = FALSE;
+
+static int  clpum_compl_accept_char(int c);
+static int  clpum_compl_add(char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int adup);
+static int  clpum_compl_equal(clpum_compl_T *match, char_u *str, int len);
+static void clpum_compl_add_matches(int num_matches, char_u **matches, int icase);
+static int  clpum_compl_make_cyclic(void);
+static void clpum_compl_upd_pum(void);
+static void clpum_compl_del_pum(void);
+static int  clpum_wanted(void);
+static int  clpum_enough_matches(void);
+static void clpum_compl_free(void);
+static void clpum_compl_clear(void);
+static int  clpum_compl_bs(void);
+static int  clpum_compl_need_restart(void);
+static void clpum_compl_new_leader(void);
+static void clpum_compl_addleader(int c);
+static int  clpum_compl_len(void);
+static void clpum_compl_restart(int redraw);
+static void clpum_compl_set_original_text(char_u *str);
+static void clpum_compl_addfrommatch(void);
+static int  clpum_compl_prep(int c);
+#if defined(FEAT_CMDL_COMPL) || defined(FEAT_EVAL)
+static void clpum_compl_add_list(list_T *list);
+static void clpum_compl_add_dict(dict_T *dict);
+#endif
+static int  clpum_compl_get_exp(pos_T *ini);
+static void clpum_compl_delete(void);
+static void clpum_compl_insert(void);
+static int  clpum_compl_next(int allow_get_expansion, int count, int insert_match);
+static int  clpum_compl_key2dir(int c);
+static int  clpum_compl_pum_key(int c);
+static int  clpum_compl_key2count(int c);
+static int  clpum_compl_use_match(int c);
+static int  clpum_complete(int c);
+#endif
+
 static int	cmdline_charsize(int idx);
 static void	set_cmdspos(void);
 static void	set_cmdspos_cursor(void);
@@ -104,6 +216,7 @@ static void	cmdline_del(int from);
 static void	redrawcmdprompt(void);
 static void	cursorcmd(void);
 static int	ccheck_abbr(int);
+static int	is_special_key(int c, int normal_key, int clpum_key);
 static int	nextwild(expand_T *xp, int type, int options, int escape);
 static void	escape_fname(char_u **pp);
 static int	showmatches(expand_T *xp, int wildmenu);
@@ -208,6 +321,15 @@ getcmdline(
     struct cmdline_info save_ccline;
 #endif
 
+#ifdef FEAT_CLPUM
+    /* Don't allow recursive cmdline mode when busy with completion. */
+    if (clpum_compl_started || clpum_compl_busy || clpum_visible())
+    {
+	EMSG(_(e_secure));
+	return NULL;
+    }
+    clpum_compl_clear();    /* clear stuff for clpum */
+#endif
 #ifdef FEAT_EVAL
     if (firstc == -1)
     {
@@ -258,6 +380,9 @@ getcmdline(
 
     ExpandInit(&xpc);
     ccline.xpc = &xpc;
+#ifdef FEAT_CLPUM
+    clpum_compl_xp = &xpc;
+#endif
 
 #ifdef FEAT_RIGHTLEFT
     if (curwin->w_p_rl && *curwin->w_p_rlc == 's'
@@ -438,8 +563,12 @@ getcmdline(
 	 * When there are matching completions to select <S-Tab> works like
 	 * CTRL-P (unless 'wc' is <S-Tab>).
 	 */
-	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)
-	    c = Ctrl_P;
+	if (c != p_wc && c == K_S_TAB && (xpc.xp_numfiles > 0
+#ifdef FEAT_CLPUM
+		    || clpum_compl_started
+#endif
+		    ))
+		c = Ctrl_P;
 
 #ifdef FEAT_WILDMENU
 	/* Special translations for 'wildmenu' */
@@ -452,15 +581,33 @@ getcmdline(
 	}
 	/* Hitting CR after "emenu Name.": complete submenu */
 	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu
-		&& ccline.cmdpos > 1
-		&& ccline.cmdbuff[ccline.cmdpos - 1] == '.'
-		&& ccline.cmdbuff[ccline.cmdpos - 2] != '\\'
 		&& (c == '\n' || c == '\r' || c == K_KENTER))
-	    c = K_DOWN;
+	{
+# ifdef FEAT_CLPUM
+	    if (clpum_compl_started)
+	    {
+		int len = (int)STRLEN(clpum_compl_shown_match->cp_str);
+
+		if (len > 1
+			&& clpum_compl_shown_match->cp_str[len - 1] == '.'
+			&& clpum_compl_shown_match->cp_str[len - 2] != '\\')
+		    c = K_RIGHT;
+	    }
+	    else
+# endif
+		if (ccline.cmdpos > 1
+			&& ccline.cmdbuff[ccline.cmdpos - 1] == '.'
+			&& ccline.cmdbuff[ccline.cmdpos - 2] != '\\')
+		    c = K_DOWN;
+	}
 #endif
 
 	/* free expanded names when finished walking through matches */
-	if (xpc.xp_numfiles != -1
+	if (1
+#ifdef FEAT_CLPUM
+		&& !clpum_compl_started
+#endif
+		&& xpc.xp_numfiles != -1
 		&& !(c == p_wc && KeyTyped) && c != p_wcm
 		&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A
 		&& c != Ctrl_L)
@@ -516,17 +663,26 @@ getcmdline(
 	/* Special translations for 'wildmenu' */
 	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu)
 	{
-	    /* Hitting <Down> after "emenu Name.": complete submenu */
-	    if (c == K_DOWN && ccline.cmdpos > 0
+#ifdef FEAT_CLPUM
+	    int c_orig = c;
+
+	    if (clpum_compl_started && (c == K_RIGHT || c == K_LEFT))
+	    {
+		clpum_compl_delete();
+		clpum_compl_insert();
+	    }
+#endif
+	    /* Hitting <Down>/<Right> after "emenu Name.": complete submenu */
+	    if (is_special_key(c, K_DOWN, K_RIGHT) && ccline.cmdpos > 0
 				  && ccline.cmdbuff[ccline.cmdpos - 1] == '.')
 		c = p_wc;
-	    else if (c == K_UP)
+	    else if (is_special_key(c, K_UP, K_LEFT))
 	    {
-		/* Hitting <Up>: Remove one submenu name in front of the
+		/* Hitting <Up>/<Left>: Remove one submenu name in front of the
 		 * cursor */
 		int found = FALSE;
 
-		j = (int)(xpc.xp_pattern - ccline.cmdbuff);
+		j = (int)(xpc.xp_pattern - xpc.xp_line);
 		i = 0;
 		while (--j > 0)
 		{
@@ -555,11 +711,19 @@ getcmdline(
 		c = p_wc;
 		xpc.xp_context = EXPAND_NOTHING;
 	    }
+
+#ifdef FEAT_CLPUM
+	    if (c != c_orig && c == p_wc)
+		clpum_compl_restart(TRUE);
+#endif
 	}
 	if ((xpc.xp_context == EXPAND_FILES
 			      || xpc.xp_context == EXPAND_DIRECTORIES
 			      || xpc.xp_context == EXPAND_SHELLCMD) && p_wmnu)
 	{
+#ifdef FEAT_CLPUM
+	    int c_orig = c;
+#endif
 	    char_u upseg[5];
 
 	    upseg[0] = PATHSEP;
@@ -568,7 +732,15 @@ getcmdline(
 	    upseg[3] = PATHSEP;
 	    upseg[4] = NUL;
 
-	    if (c == K_DOWN
+#ifdef FEAT_CLPUM
+	    if (clpum_compl_started && (c == K_RIGHT || c == K_LEFT))
+	    {
+		clpum_compl_delete();
+		clpum_compl_insert();
+	    }
+#endif
+
+	    if (is_special_key(c, K_DOWN, K_RIGHT)
 		    && ccline.cmdpos > 0
 		    && ccline.cmdbuff[ccline.cmdpos - 1] == PATHSEP
 		    && (ccline.cmdpos < 3
@@ -578,13 +750,14 @@ getcmdline(
 		/* go down a directory */
 		c = p_wc;
 	    }
-	    else if (STRNCMP(xpc.xp_pattern, upseg + 1, 3) == 0 && c == K_DOWN)
+	    else if (STRNCMP(xpc.xp_pattern, upseg + 1, 3) == 0
+		    && is_special_key(c, K_DOWN, K_RIGHT))
 	    {
 		/* If in a direct ancestor, strip off one ../ to go down */
 		int found = FALSE;
 
 		j = ccline.cmdpos;
-		i = (int)(xpc.xp_pattern - ccline.cmdbuff);
+		i = (int)(xpc.xp_pattern - xpc.xp_line);
 		while (--j > i)
 		{
 #ifdef FEAT_MBYTE
@@ -606,13 +779,13 @@ getcmdline(
 		    c = p_wc;
 		}
 	    }
-	    else if (c == K_UP)
+	    else if (is_special_key(c, K_UP, K_LEFT))
 	    {
 		/* go up a directory */
 		int found = FALSE;
 
 		j = ccline.cmdpos - 1;
-		i = (int)(xpc.xp_pattern - ccline.cmdbuff);
+		i = (int)(xpc.xp_pattern - xpc.xp_line);
 		while (--j > i)
 		{
 #ifdef FEAT_MBYTE
@@ -660,10 +833,72 @@ getcmdline(
 		c = p_wc;
 		KeyTyped = TRUE;
 	    }
+
+#ifdef FEAT_CLPUM
+	    if (c != c_orig && c == p_wc)
+		clpum_compl_restart(TRUE);
+#endif
 	}
 
 #endif	/* FEAT_WILDMENU */
 
+#ifdef FEAT_CLPUM
+	/*
+	 * Special handling of keys while the popup menu is visible or wanted
+	 * and the cursor is still in the completed word.  Only when there is
+	 * a match, skip this when no matches were found.
+	 */
+	if (clpum_compl_started
+		&& clpum_wanted()
+		&& ccline.cmdpos >= clpum_compl_col
+		&& (clpum_compl_shown_match == NULL
+		|| clpum_compl_shown_match != clpum_compl_shown_match->cp_next))
+	{
+	    /* BS: Delete one character from "compl_leader". */
+	    if ((c == K_BS || c == Ctrl_H)
+			&& ccline.cmdpos > clpum_compl_col
+			&& (c = clpum_compl_bs()) == NUL)
+		    goto cmdline_changed;
+
+	    /* When no match was selected or it was edited. */
+	    if (!clpum_compl_used_match)
+	    {
+		/* CTRL-L: Add one character from the current match to
+		 * "compl_leader".  Except when at the original match and
+		 * there is nothing to add, CTRL-L works like CTRL-P then. */
+		if (c == Ctrl_L
+			&& ((int)STRLEN(clpum_compl_shown_match->cp_str)
+					  > ccline.cmdpos - clpum_compl_col))
+		{
+		    clpum_compl_addfrommatch();
+		    goto cmdline_changed;
+		}
+
+		/* A non-white character that fits in with the current
+		 * completion: Add to "compl_leader". */
+		if (clpum_compl_accept_char(c))
+		{
+		    clpum_compl_addleader(c);
+		    goto cmdline_changed;
+		}
+
+		/* Pressing CTRL-Y selects the current match.  When
+		 * compl_enter_selects is set the Enter key does the same. */
+		if (c == Ctrl_Y || (clpum_compl_enter_selects
+				   && (c == CAR || c == K_KENTER || c == NL)))
+		{
+		    clpum_compl_delete();
+		    clpum_compl_insert();
+		}
+	    }
+	}
+
+	/* Prepare for or stop CTRL-X mode.  This doesn't do completion, but
+	 * it does fix up the text when finishing completion. */
+	if (clpum_compl_prep(c))
+	    goto cmdline_changed;
+#endif
+
 	/* CTRL-\ CTRL-N goes to Normal mode, CTRL-\ CTRL-G goes to Insert
 	 * mode when 'insertmode' is set, CTRL-\ e prompts for an expression. */
 	if (c == Ctrl_BSL)
@@ -805,102 +1040,161 @@ getcmdline(
 	 * - wildcard expansion is only done when the 'wildchar' key is really
 	 *   typed, not when it comes from a macro
 	 */
-	if ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)
+	if (((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)
+		/* only expansion for ':', '>' and '=' command-lines */
+		&& (ccline.cmdfirstc == ':'
+#ifdef FEAT_EVAL
+		|| ccline.cmdfirstc == '>' || ccline.cmdfirstc == '='
+		|| ccline.input_fn
+#endif
+	   ))
 	{
-	    if (xpc.xp_numfiles > 0)   /* typed p_wc at least twice */
+	    /* typed p_wc at least twice */
+	    if (xpc.xp_numfiles > 0
+#ifdef FEAT_CLPUM
+		    || clpum_compl_started
+#endif
+	       )
 	    {
-		/* if 'wildmode' contains "list" may still need to list */
-		if (xpc.xp_numfiles > 1
-			&& !did_wild_list
-			&& (wim_flags[wim_index] & WIM_LIST))
+#ifdef FEAT_CLPUM
+		if ((wim_flags[wim_index] & WIM_POPUP) && p_wmnu)
 		{
-		    (void)showmatches(&xpc, FALSE);
-		    redrawcmd();
-		    did_wild_list = TRUE;
+		    int adjust = FALSE;
+
+		    if (xpc.xp_numfiles > 0)
+		    {
+			if (!(wim_flags[wim_index - 1] & WIM_LONGEST))
+			    adjust = TRUE;
+			if (adjust)
+			    nextwild(&xpc, WILD_PREV, 0, firstc != '@');
+			(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);
+		    }
+		    clpum_compl_busy = TRUE;
+		    res = clpum_complete(c);
+		    if (adjust)
+			res = clpum_complete(clpum_compl_no_insert ? K_DOWN
+								    : Ctrl_N);
+		    clpum_compl_busy = FALSE;
 		}
-		if (wim_flags[wim_index] & WIM_LONGEST)
-		    res = nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
-							       firstc != '@');
-		else if (wim_flags[wim_index] & WIM_FULL)
-		    res = nextwild(&xpc, WILD_NEXT, WILD_NO_BEEP,
-							       firstc != '@');
 		else
-		    res = OK;	    /* don't insert 'wildchar' now */
+#endif
+		{
+		    /* if 'wildmode' contains "list" may still need to list */
+		    if (xpc.xp_numfiles > 1
+			    && !did_wild_list
+			    && (wim_flags[wim_index] & WIM_LIST))
+		    {
+			(void)showmatches(&xpc, FALSE);
+			redrawcmd();
+			did_wild_list = TRUE;
+		    }
+		    if (wim_flags[wim_index] & WIM_LONGEST)
+			res = nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
+								firstc != '@');
+		    else if (wim_flags[wim_index] & WIM_FULL)
+			res = nextwild(&xpc, WILD_NEXT, WILD_NO_BEEP,
+								firstc != '@');
+		    else
+			res = OK;	    /* don't insert 'wildchar' now */
+		}
 	    }
 	    else		    /* typed p_wc first time */
 	    {
 		wim_index = 0;
 		j = ccline.cmdpos;
-		/* if 'wildmode' first contains "longest", get longest
-		 * common part */
-		if (wim_flags[0] & WIM_LONGEST)
-		    res = nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
-							       firstc != '@');
-		else
-		    res = nextwild(&xpc, WILD_EXPAND_KEEP, WILD_NO_BEEP,
-							       firstc != '@');
 
-		/* if interrupted while completing, behave like it failed */
-		if (got_int)
+#ifdef FEAT_CLPUM
+		if ((wim_flags[0] & WIM_POPUP) && p_wmnu)
 		{
-		    (void)vpeekc();	/* remove <C-C> from input stream */
-		    got_int = FALSE;	/* don't abandon the command line */
-		    (void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);
-#ifdef FEAT_WILDMENU
-		    xpc.xp_context = EXPAND_NOTHING;
-#endif
-		    goto cmdline_changed;
+		    clpum_compl_busy = TRUE;
+		    res = clpum_complete(c);
+		    clpum_compl_busy = FALSE;
 		}
-
-		/* when more than one match, and 'wildmode' first contains
-		 * "list", or no change and 'wildmode' contains "longest,list",
-		 * list all matches */
-		if (res == OK && xpc.xp_numfiles > 1)
+		else
+#endif
 		{
-		    /* a "longest" that didn't do anything is skipped (but not
-		     * "list:longest") */
-		    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)
-			wim_index = 1;
-		    if ((wim_flags[wim_index] & WIM_LIST)
+
+		    /* if 'wildmode' first contains "longest", get longest
+		    * common part */
+		    if (wim_flags[0] & WIM_LONGEST)
+			res = nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
+								firstc != '@');
+		    else
+			res = nextwild(&xpc, WILD_EXPAND_KEEP, WILD_NO_BEEP,
+								firstc != '@');
+
+		    /* if interrupted while completing, behave like it failed */
+		    if (got_int)
+		    {
+			(void)vpeekc();	/* remove <C-C> from input stream */
+			got_int = FALSE;	/* don't abandon the command line */
+			(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);
 #ifdef FEAT_WILDMENU
-			    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)
+			xpc.xp_context = EXPAND_NOTHING;
 #endif
-			    )
+			goto cmdline_changed;
+		    }
+
+		    /* when more than one match, and 'wildmode' first contains
+		    * "list", or no change and 'wildmode' contains "longest,list",
+		    * list all matches */
+		    if (res == OK && xpc.xp_numfiles > 1)
 		    {
-			if (!(wim_flags[0] & WIM_LONGEST))
+			/* a "longest" that didn't do anything is skipped (but not
+			* "list:longest") */
+			if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)
+			    wim_index = 1;
+#ifdef FEAT_CLPUM
+			if ((wim_flags[wim_index] & WIM_POPUP) && p_wmnu)
 			{
+			    (void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);
+			    clpum_compl_busy = TRUE;
+			    res = clpum_complete(c);
+			    clpum_compl_busy = FALSE;
+			}
+			else
+#endif
+			    if ((wim_flags[wim_index] & WIM_LIST)
 #ifdef FEAT_WILDMENU
-			    int p_wmnu_save = p_wmnu;
-			    p_wmnu = 0;
+				|| (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)
 #endif
-			    /* remove match */
-			    nextwild(&xpc, WILD_PREV, 0, firstc != '@');
+				)
+			{
+			    if (!(wim_flags[0] & WIM_LONGEST))
+			    {
 #ifdef FEAT_WILDMENU
-			    p_wmnu = p_wmnu_save;
+				int p_wmnu_save = p_wmnu;
+				p_wmnu = 0;
 #endif
-			}
+				/* remove match */
+				nextwild(&xpc, WILD_PREV, 0, firstc != '@');
+#ifdef FEAT_WILDMENU
+				p_wmnu = p_wmnu_save;
+#endif
+			    }
 #ifdef FEAT_WILDMENU
-			(void)showmatches(&xpc, p_wmnu
-				&& ((wim_flags[wim_index] & WIM_LIST) == 0));
+			    (void)showmatches(&xpc, p_wmnu
+				    && ((wim_flags[wim_index] & WIM_LIST) == 0));
 #else
-			(void)showmatches(&xpc, FALSE);
+			    (void)showmatches(&xpc, FALSE);
 #endif
-			redrawcmd();
-			did_wild_list = TRUE;
-			if (wim_flags[wim_index] & WIM_LONGEST)
-			    nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
-							       firstc != '@');
-			else if (wim_flags[wim_index] & WIM_FULL)
-			    nextwild(&xpc, WILD_NEXT, WILD_NO_BEEP,
-							       firstc != '@');
+			    redrawcmd();
+			    did_wild_list = TRUE;
+			    if (wim_flags[wim_index] & WIM_LONGEST)
+				nextwild(&xpc, WILD_LONGEST, WILD_NO_BEEP,
+								firstc != '@');
+			    else if (wim_flags[wim_index] & WIM_FULL)
+				nextwild(&xpc, WILD_NEXT, WILD_NO_BEEP,
+								firstc != '@');
+			}
+			else
+			    vim_beep(BO_WILD);
 		    }
-		    else
-			vim_beep(BO_WILD);
-		}
 #ifdef FEAT_WILDMENU
-		else if (xpc.xp_numfiles == -1)
-		    xpc.xp_context = EXPAND_NOTHING;
+		    else if (xpc.xp_numfiles == -1)
+			xpc.xp_context = EXPAND_NOTHING;
 #endif
+		}
 	    }
 	    if (wim_index < 3)
 		++wim_index;
@@ -913,7 +1207,11 @@ getcmdline(
 	gotesc = FALSE;
 
 	/* <S-Tab> goes to last match, in a clumsy way */
-	if (c == K_S_TAB && KeyTyped)
+	if (
+#ifdef FEAT_CLPUM
+	    !clpum_compl_started &&
+#endif
+	    c == K_S_TAB && KeyTyped)
 	{
 	    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK
 		    && nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK
@@ -1024,6 +1322,7 @@ getcmdline(
 		    redraw_cmdline = TRUE;
 		    goto returncmd;		/* back to cmd mode */
 		}
+
 		goto cmdline_changed;
 
 	case K_INS:
@@ -1195,11 +1494,26 @@ getcmdline(
 		goto cmdline_changed;
 
 	case Ctrl_D:
-		if (showmatches(&xpc, FALSE) == EXPAND_NOTHING)
-		    break;	/* Use ^D as normal char instead */
+#ifdef FEAT_CLPUM
+		if (!clpum_compl_started)
+#endif
+		{
+		    if (showmatches(&xpc, FALSE) == EXPAND_NOTHING)
+			break;	/* Use ^D as normal char instead */
 
-		redrawcmd();
-		continue;	/* don't do incremental search now */
+		    redrawcmd();
+		}
+		goto cmdline_not_changed;
+
+	case Ctrl_X:
+#ifdef FEAT_CLPUM
+		clpum_compl_busy = TRUE;
+		clpum_complete(c);
+		clpum_compl_busy = FALSE;
+		goto cmdline_changed;
+#else
+		goto cmdline_not_changed;
+#endif
 
 	case K_RIGHT:
 	case K_S_RIGHT:
@@ -1473,6 +1787,17 @@ getcmdline(
 
 	case Ctrl_N:	    /* next match */
 	case Ctrl_P:	    /* previous match */
+#ifdef FEAT_CLPUM
+		if (clpum_compl_started || clpum_visible())
+		{
+docomplete:
+		    clpum_compl_busy = TRUE;
+		    clpum_complete(c);
+		    clpum_compl_busy = FALSE;
+		    goto cmdline_changed;
+		}
+#endif
+
 		if (xpc.xp_numfiles > 0)
 		{
 		    if (nextwild(&xpc, (c == Ctrl_P) ? WILD_PREV : WILD_NEXT,
@@ -1480,8 +1805,7 @@ getcmdline(
 			break;
 		    goto cmdline_changed;
 		}
-
-#ifdef FEAT_CMDHIST
+		/* FALLTHROUGH */
 	case K_UP:
 	case K_DOWN:
 	case K_S_UP:
@@ -1490,6 +1814,11 @@ getcmdline(
 	case K_KPAGEUP:
 	case K_PAGEDOWN:
 	case K_KPAGEDOWN:
+#ifdef FEAT_CLPUM
+		if (clpum_visible())
+		    goto docomplete;
+#endif
+#ifdef FEAT_CMDHIST
 		if (hislen == 0 || firstc == NUL)	/* no history */
 		    goto cmdline_not_changed;
 
@@ -1623,8 +1952,8 @@ getcmdline(
 		    goto cmdline_changed;
 		}
 		beep_flush();
-		goto cmdline_not_changed;
 #endif
+		goto cmdline_not_changed;
 
 	case Ctrl_V:
 	case Ctrl_Q:
@@ -1875,6 +2204,13 @@ getcmdline(
 	    if (vpeekc() == NUL)
 		redrawcmd();
 #endif
+#ifdef FEAT_CLPUM
+	if (clpum_compl_started)
+	{
+	    redrawcmd();
+	    showmode();
+	}
+#endif
     }
 
 returncmd:
@@ -1889,6 +2225,9 @@ getcmdline(
 
     ExpandCleanup(&xpc);
     ccline.xpc = NULL;
+#ifdef FEAT_CLPUM
+    clpum_compl_xp = NULL;
+#endif
 
 #ifdef FEAT_SEARCH_EXTRA
     if (did_incsearch)
@@ -2829,6 +3168,8 @@ put_on_cmdline(char_u *str, int len, int redraw)
     int		m;
     int		c;
 
+    set_cmdspos_cursor();
+
     if (len < 0)
 	len = (int)STRLEN(str);
 
@@ -3004,6 +3345,9 @@ save_cmdline(struct cmdline_info *ccp)
     ccline.cmdbuff = NULL;
     ccline.cmdprompt = NULL;
     ccline.xpc = NULL;
+#ifdef FEAT_CLPUM
+    clpum_compl_xp = NULL;
+#endif
 }
 
 /*
@@ -3014,6 +3358,9 @@ restore_cmdline(struct cmdline_info *ccp)
 {
     ccline = prev_ccline;
     prev_ccline = *ccp;
+#ifdef FEAT_CLPUM
+    clpum_compl_xp = ccline.xpc;
+#endif
 }
 
 #if defined(FEAT_EVAL) || defined(PROTO)
@@ -3202,6 +3549,10 @@ redrawcmdline(void)
     need_wait_return = FALSE;
     compute_cmdrow();
     redrawcmd();
+#ifdef FEAT_CLPUM
+    if (clpum_visible())
+	showmode();
+#endif
     cursorcmd();
 }
 
@@ -3355,6 +3706,25 @@ sort_func_compare(const void *s1, const void *s2)
 #endif
 
 /*
+ * Return TRUE if c is expected key
+ */
+    static int
+is_special_key(
+    int c,
+    int normal_key,
+    int clpum_key UNUSED)
+{
+    return
+#ifdef FEAT_CLPUM
+		    ((!clpum_compl_started && c == normal_key) ||
+			(clpum_compl_started && c == clpum_key))
+#else
+		    c == normal_key
+#endif
+	   ;
+}
+
+/*
  * Return FAIL if this is not an appropriate context in which to do
  * completion of anything, return OK if it is (even if there are no matches).
  * For the caller, this means that the character is just passed through like a
@@ -5688,6 +6058,8 @@ get_history_idx(int histype)
     return history[histype][hisidx[histype]].hisnum;
 }
 
+static struct cmdline_info *get_ccline_ptr(void);
+
 /*
  * Calculate history index from a number:
  *   num > 0: seen as identifying number of a history entry
@@ -5931,6 +6303,21 @@ get_cmdline_str(void)
 }
 
 /*
+ * Get the current command line length.
+ * Only works when the command line is being edited.
+ * Returns -1 when something is wrong.
+ */
+    int
+get_cmdline_len(void)
+{
+    struct cmdline_info *p = get_ccline_ptr();
+
+    if (p == NULL)
+	return -1;
+    return p->cmdlen;
+}
+
+/*
  * Get the current command line position, counted in bytes.
  * Zero is the first position.
  * Only works when the command line is being edited.
@@ -6982,3 +7369,2009 @@ script_get(exarg_T *eap, char_u *cmd)
 
     return (char_u *)ga.ga_data;
 }
+
+#if defined(FEAT_CLPUM) || defined(PROTO)
+/*
+ * Is the character 'c' a valid key to go to or keep us in CTRL-X mode?
+ * This depends on the current mode.
+ */
+    int
+vim_is_clpum_key(int c)
+{
+    /* Accept <PageUp> and <PageDown> if the popup menu is visible. */
+    if (clpum_compl_pum_key(c))
+	return TRUE;
+
+    return ((c == p_wc && KeyTyped) || c == p_wcm
+				|| c == Ctrl_X || c == Ctrl_P || c == Ctrl_N);
+}
+
+/*
+ * Return TRUE when character "c" is part of the item currently being
+ * completed.  Used to decide whether to abandon complete mode when the menu
+ * is visible.
+ */
+    static int
+clpum_compl_accept_char(int c)
+{
+    /* Command line completion can work with just about any
+     * printable character, but do stop at white space. */
+    return vim_isprintc(c) && !vim_iswhite(c);
+}
+
+/*
+ * This is like clpum_compl_add(), but if 'ic' and 'inf' are set, then the
+ * case of the originally typed text is used, and the case of the completed
+ * text is inferred, ie this tries to work out what case you probably wanted
+ * the rest of the word to be in -- webb
+ */
+    int
+clpum_compl_add_infercase(
+    char_u	*str,
+    int		len,
+    int		icase,
+    char_u	*fname,
+    int		dir,
+    int		flags)
+{
+    char_u	*p;
+    int		i, c;
+    int		actual_len;		/* Take multi-byte characters */
+    int		actual_compl_length;	/* into account. */
+    int		min_len;
+    int		*wca;			/* Wide character array. */
+    int		has_lower = FALSE;
+    int		was_letter = FALSE;
+
+    if (p_ic && curbuf->b_p_inf && len > 0)
+    {
+	/* Infer case of completed part. */
+
+	/* Find actual length of completion. */
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    p = str;
+	    actual_len = 0;
+	    while (*p != NUL)
+	    {
+		mb_ptr_adv(p);
+		++actual_len;
+	    }
+	}
+	else
+#endif
+	    actual_len = len;
+
+	/* Find actual length of original text. */
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    p = clpum_compl_orig_text;
+	    actual_compl_length = 0;
+	    while (*p != NUL)
+	    {
+		mb_ptr_adv(p);
+		++actual_compl_length;
+	    }
+	}
+	else
+#endif
+	    actual_compl_length = clpum_compl_length;
+
+	/* "actual_len" may be smaller than "actual_compl_length" when using
+	 * thesaurus, only use the minimum when comparing. */
+	min_len = actual_len < actual_compl_length
+					   ? actual_len : actual_compl_length;
+
+	/* Allocate wide character array for the completion and fill it. */
+	wca = (int *)alloc((unsigned)(actual_len * sizeof(int)));
+	if (wca != NULL)
+	{
+	    p = str;
+	    for (i = 0; i < actual_len; ++i)
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    wca[i] = mb_ptr2char_adv(&p);
+		else
+#endif
+		    wca[i] = *(p++);
+
+	    /* Rule 1: Were any chars converted to lower? */
+	    p = clpum_compl_orig_text;
+	    for (i = 0; i < min_len; ++i)
+	    {
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    c = mb_ptr2char_adv(&p);
+		else
+#endif
+		    c = *(p++);
+		if (MB_ISLOWER(c))
+		{
+		    has_lower = TRUE;
+		    if (MB_ISUPPER(wca[i]))
+		    {
+			/* Rule 1 is satisfied. */
+			for (i = actual_compl_length; i < actual_len; ++i)
+			    wca[i] = MB_TOLOWER(wca[i]);
+			break;
+		    }
+		}
+	    }
+
+	    /*
+	     * Rule 2: No lower case, 2nd consecutive letter converted to
+	     * upper case.
+	     */
+	    if (!has_lower)
+	    {
+		p = clpum_compl_orig_text;
+		for (i = 0; i < min_len; ++i)
+		{
+#ifdef FEAT_MBYTE
+		    if (has_mbyte)
+			c = mb_ptr2char_adv(&p);
+		    else
+#endif
+			c = *(p++);
+		    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))
+		    {
+			/* Rule 2 is satisfied. */
+			for (i = actual_compl_length; i < actual_len; ++i)
+			    wca[i] = MB_TOUPPER(wca[i]);
+			break;
+		    }
+		    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);
+		}
+	    }
+
+	    /* Copy the original case of the part we typed. */
+	    p = clpum_compl_orig_text;
+	    for (i = 0; i < min_len; ++i)
+	    {
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    c = mb_ptr2char_adv(&p);
+		else
+#endif
+		    c = *(p++);
+		if (MB_ISLOWER(c))
+		    wca[i] = MB_TOLOWER(wca[i]);
+		else if (MB_ISUPPER(c))
+		    wca[i] = MB_TOUPPER(wca[i]);
+	    }
+
+	    /*
+	     * Generate encoding specific output from wide character array.
+	     * Multi-byte characters can occupy up to five bytes more than
+	     * ASCII characters, and we also need one byte for NUL, so stay
+	     * six bytes away from the edge of IObuff.
+	     */
+	    p = IObuff;
+	    i = 0;
+	    while (i < actual_len && (p - IObuff + 6) < IOSIZE)
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		    p += (*mb_char2bytes)(wca[i++], p);
+		else
+#endif
+		    *(p++) = wca[i++];
+	    *p = NUL;
+
+	    vim_free(wca);
+	}
+
+	return clpum_compl_add(IObuff, len, icase, fname, NULL, dir,
+								flags, FALSE);
+    }
+    return clpum_compl_add(str, len, icase, fname, NULL, dir, flags, FALSE);
+}
+
+/*
+ * Add a match to the list of matches.
+ * If the given string is already in the list of completions, then return
+ * NOTDONE, otherwise add it to the list and return OK.  If there is an error,
+ * maybe because alloc() returns NULL, then FAIL is returned.
+ */
+    static int
+clpum_compl_add(
+    char_u	*str,
+    int		len,
+    int		icase,
+    char_u	*fname,
+    char_u	**cptext,   /* extra text for popup menu or NULL */
+    int		cdir,
+    int		flags,
+    int		adup)	    /* accept duplicate match */
+{
+    clpum_compl_T	*match;
+    int		dir = (cdir == 0 ? clpum_compl_direction : cdir);
+
+    ui_breakcheck();
+    if (got_int)
+	return FAIL;
+    if (len < 0)
+	len = (int)STRLEN(str);
+
+    /*
+     * If the same match is already present, don't add it.
+     */
+    if (clpum_compl_first_match != NULL && !adup)
+    {
+	match = clpum_compl_first_match;
+	do
+	{
+	    if (    !(match->cp_flags & ORIGINAL_TEXT)
+		    && STRNCMP(match->cp_str, str, len) == 0
+		    && match->cp_str[len] == NUL)
+		return NOTDONE;
+	    match = match->cp_next;
+	} while (match != NULL && match != clpum_compl_first_match);
+    }
+
+    /* Remove any popup menu before changing the list of matches. */
+    clpum_compl_del_pum();
+
+    /*
+     * Allocate a new match structure.
+     * Copy the values to the new match structure.
+     */
+    match = (clpum_compl_T *)alloc_clear((unsigned)sizeof(clpum_compl_T));
+    if (match == NULL)
+	return FAIL;
+    match->cp_number = -1;
+    if (flags & ORIGINAL_TEXT)
+	match->cp_number = 0;
+    if ((match->cp_str = vim_strnsave(str, len)) == NULL)
+    {
+	vim_free(match);
+	return FAIL;
+    }
+    match->cp_icase = icase;
+
+    /* match-fname is:
+     * - clpum_compl_curr_match->cp_fname if it is a string equal to fname.
+     * - a copy of fname, FREE_FNAME is set to free later THE allocated mem.
+     * - NULL otherwise.	--Acevedo */
+    if (fname != NULL
+	    && clpum_compl_curr_match != NULL
+	    && clpum_compl_curr_match->cp_fname != NULL
+	    && STRCMP(fname, clpum_compl_curr_match->cp_fname) == 0)
+	match->cp_fname = clpum_compl_curr_match->cp_fname;
+    else if (fname != NULL)
+    {
+	match->cp_fname = vim_strsave(fname);
+	flags |= FREE_FNAME;
+    }
+    else
+	match->cp_fname = NULL;
+    match->cp_flags = flags;
+
+    if (cptext != NULL)
+    {
+	int i;
+
+	for (i = 0; i < CPT_COUNT; ++i)
+	    if (cptext[i] != NULL && *cptext[i] != NUL)
+		match->cp_text[i] = vim_strsave(cptext[i]);
+    }
+
+    /*
+     * Link the new match structure in the list of matches.
+     */
+    if (clpum_compl_first_match == NULL)
+	match->cp_next = match->cp_prev = NULL;
+    else if (dir == FORWARD)
+    {
+	match->cp_next = clpum_compl_curr_match->cp_next;
+	match->cp_prev = clpum_compl_curr_match;
+    }
+    else	/* BACKWARD */
+    {
+	match->cp_next = clpum_compl_curr_match;
+	match->cp_prev = clpum_compl_curr_match->cp_prev;
+    }
+    if (match->cp_next)
+	match->cp_next->cp_prev = match;
+    if (match->cp_prev)
+	match->cp_prev->cp_next = match;
+    else	/* if there's nothing before, it is the first match */
+	clpum_compl_first_match = match;
+    clpum_compl_curr_match = match;
+
+    return OK;
+}
+
+/*
+ * Return TRUE if "str[len]" matches with match->cp_str, considering
+ * match->cp_icase.
+ */
+    static int
+clpum_compl_equal(
+    clpum_compl_T	*match,
+    char_u	*str,
+    int		len)
+{
+    if (match->cp_icase)
+	return STRNICMP(match->cp_str, str, (size_t)len) == 0;
+    return STRNCMP(match->cp_str, str, (size_t)len) == 0;
+}
+
+/*
+ * Add an array of matches to the list of matches.
+ * Frees matches[].
+ */
+    static void
+clpum_compl_add_matches(
+    int		num_matches,
+    char_u	**matches,
+    int		icase)
+{
+    int		i;
+    int		add_r = OK;
+    int		dir = clpum_compl_direction;
+
+    for (i = 0; i < num_matches && add_r != FAIL; i++)
+	if ((add_r = clpum_compl_add(matches[i], -1, icase,
+					    NULL, NULL, dir, 0, FALSE)) == OK)
+	    /* if dir was BACKWARD then honor it just once */
+	    dir = FORWARD;
+    FreeWild(num_matches, matches);
+}
+
+/* Make the completion list cyclic.
+ * Return the number of matches (excluding the original).
+ */
+    static int
+clpum_compl_make_cyclic(void)
+{
+    clpum_compl_T *match;
+    int	    count = 0;
+
+    if (clpum_compl_first_match != NULL)
+    {
+	/*
+	 * Find the end of the list.
+	 */
+	match = clpum_compl_first_match;
+	/* there's always an entry for the clpum_compl_orig_text, it doesn't
+	 * count. */
+	while (match->cp_next != NULL && match->cp_next
+						    != clpum_compl_first_match)
+	{
+	    match = match->cp_next;
+	    ++count;
+	}
+	match->cp_next = clpum_compl_first_match;
+	clpum_compl_first_match->cp_prev = match;
+    }
+    return count;
+}
+
+/*
+ * Set variables that store noselect and noinsert behavior from the
+ * 'clcompleteopt' value.
+ */
+    void
+clpum_completeopt_was_set()
+{
+    clpum_compl_no_insert = FALSE;
+    clpum_compl_no_select = FALSE;
+    if (strstr((char *)p_clcot, "noselect") != NULL)
+	clpum_compl_no_select = TRUE;
+    if (strstr((char *)p_clcot, "noinsert") != NULL)
+	clpum_compl_no_insert = TRUE;
+}
+
+/* "clpum_compl_match_array" points the currently displayed list of entries in
+ * the popup menu.  It is NULL when there is no popup menu. */
+static pumitem_T *clpum_compl_match_array = NULL;
+static int clpum_compl_match_arraysize;
+
+/*
+ * Update the screen and when there is any scrolling remove the popup menu.
+ */
+    static void
+clpum_compl_upd_pum(void)
+{
+    int		h;
+
+    if (clpum_compl_match_array != NULL)
+    {
+	h = curwin->w_cline_height;
+	update_screen(0);
+	if (h != curwin->w_cline_height)
+	    clpum_compl_del_pum();
+    }
+}
+
+/*
+ * Remove any popup menu.
+ */
+    static void
+clpum_compl_del_pum(void)
+{
+    if (clpum_compl_match_array != NULL)
+    {
+	clpum_undisplay();
+	vim_free(clpum_compl_match_array);
+	clpum_compl_match_array = NULL;
+    }
+}
+
+/*
+ * Return TRUE if the popup menu should be displayed.
+ */
+    static int
+clpum_wanted(void)
+{
+    /* 'clcompleteopt' must contain "menu" or "menuone" */
+    if (strstr((char *)p_clcot, "menu") == NULL)
+	return FALSE;
+
+    /* The display looks bad on a B&W display. */
+    if (t_colors < 8
+#ifdef FEAT_GUI
+	    && !gui.in_use
+#endif
+	    )
+	return FALSE;
+    return TRUE;
+}
+
+/*
+ * Return TRUE if there are two or more matches to be shown in the popup menu.
+ * One if 'clcompletopt' contains "menuone".
+ */
+    static int
+clpum_enough_matches(void)
+{
+    clpum_compl_T     *compl;
+    int		i;
+
+    /* Don't display the popup menu if there are no matches or there is only
+     * one (ignoring the original text). */
+    compl = clpum_compl_first_match;
+    i = 0;
+    do
+    {
+	if (compl == NULL
+		      || ((compl->cp_flags & ORIGINAL_TEXT) == 0 && ++i == 2))
+	    break;
+	compl = compl->cp_next;
+    } while (compl != clpum_compl_first_match);
+
+    if (strstr((char *)p_clcot, "menuone") != NULL)
+	return (i >= 1);
+    return (i >= 2);
+}
+
+/*
+ * Show the popup menu for the list of matches.
+ * Also adjusts "clpum_compl_shown_match" to an entry that is actually
+ * displayed.
+ */
+    void
+clpum_compl_show_pum(void)
+{
+    clpum_compl_T     *compl;
+    clpum_compl_T     *shown_compl = NULL;
+    int		did_find_shown_match = FALSE;
+    int		shown_match_ok = FALSE;
+    int		i;
+    int		cur = -1;
+    colnr_T	col;
+    int		lead_len = 0;
+
+    if (!clpum_wanted() || !clpum_enough_matches())
+	return;
+
+#if defined(FEAT_EVAL)
+    /* Dirty hard-coded hack: remove any matchparen highlighting. */
+    do_cmdline_cmd((char_u *)"if exists('g:loaded_matchparen')|3match none"
+			    "|endif");
+#endif
+
+    /* Update the screen before drawing the popup menu over it. */
+    update_screen(0);
+
+    if (clpum_compl_match_array == NULL)
+    {
+	/* Need to build the popup menu list. */
+	clpum_compl_match_arraysize = 0;
+	compl = clpum_compl_first_match;
+	if (clpum_compl_leader != NULL)
+	    lead_len = (int)STRLEN(clpum_compl_leader);
+	do
+	{
+	    if ((compl->cp_flags & ORIGINAL_TEXT) == 0
+		    && (clpum_compl_leader == NULL
+			|| clpum_compl_equal(compl, clpum_compl_leader,
+								    lead_len)))
+		++clpum_compl_match_arraysize;
+	    compl = compl->cp_next;
+	} while (compl != NULL && compl != clpum_compl_first_match);
+	if (clpum_compl_match_arraysize == 0)
+	    return;
+	clpum_compl_match_array = (pumitem_T *)alloc_clear(
+				    (unsigned)(sizeof(pumitem_T)
+						* clpum_compl_match_arraysize));
+	if (clpum_compl_match_array != NULL)
+	{
+	    /* If the current match is the original text don't find the first
+	     * match after it, don't highlight anything. */
+	    if (clpum_compl_shown_match->cp_flags & ORIGINAL_TEXT)
+		shown_match_ok = TRUE;
+
+	    i = 0;
+	    compl = clpum_compl_first_match;
+	    do
+	    {
+		if ((compl->cp_flags & ORIGINAL_TEXT) == 0
+			&& (clpum_compl_leader == NULL
+			    || clpum_compl_equal(compl, clpum_compl_leader,
+								    lead_len)))
+		{
+		    if (!shown_match_ok)
+		    {
+			if (compl == clpum_compl_shown_match
+							|| did_find_shown_match)
+			{
+			    /* This item is the shown match or this is the
+			     * first displayed item after the shown match. */
+			    clpum_compl_shown_match = compl;
+			    did_find_shown_match = TRUE;
+			    shown_match_ok = TRUE;
+			}
+			else
+			    /* Remember this displayed match for when the
+			     * shown match is just below it. */
+			    shown_compl = compl;
+			cur = i;
+		    }
+
+		    if (compl->cp_text[CPT_ABBR] != NULL)
+			clpum_compl_match_array[i].pum_text =
+						     compl->cp_text[CPT_ABBR];
+		    else
+			clpum_compl_match_array[i].pum_text = compl->cp_str;
+		    clpum_compl_match_array[i].pum_kind =
+						    compl->cp_text[CPT_KIND];
+		    clpum_compl_match_array[i].pum_info =
+						    compl->cp_text[CPT_INFO];
+		    if (compl->cp_text[CPT_MENU] != NULL)
+			clpum_compl_match_array[i++].pum_extra =
+						     compl->cp_text[CPT_MENU];
+		    else
+			clpum_compl_match_array[i++].pum_extra =
+							    compl->cp_fname;
+		}
+
+		if (compl == clpum_compl_shown_match)
+		{
+		    did_find_shown_match = TRUE;
+
+		    /* When the original text is the shown match don't set
+		     * clpum_compl_shown_match. */
+		    if (compl->cp_flags & ORIGINAL_TEXT)
+			shown_match_ok = TRUE;
+
+		    if (!shown_match_ok && shown_compl != NULL)
+		    {
+			/* The shown match isn't displayed, set it to the
+			 * previously displayed match. */
+			clpum_compl_shown_match = shown_compl;
+			shown_match_ok = TRUE;
+		    }
+		}
+		compl = compl->cp_next;
+	    } while (compl != NULL && compl != clpum_compl_first_match);
+
+	    if (!shown_match_ok)    /* no displayed match at all */
+		cur = -1;
+	}
+    }
+    else
+    {
+	/* popup menu already exists, only need to find the current item.*/
+	for (i = 0; i < clpum_compl_match_arraysize; ++i)
+	    if (clpum_compl_match_array[i].pum_text
+					    == clpum_compl_shown_match->cp_str
+		    || clpum_compl_match_array[i].pum_text
+				== clpum_compl_shown_match->cp_text[CPT_ABBR])
+	    {
+		cur = i;
+		break;
+	    }
+    }
+
+    if (clpum_compl_match_array != NULL)
+    {
+	int disp_col = clpum_compl_col + 1;
+
+	/* In Replace mode when a $ is displayed at the end of the line only
+	 * part of the screen would be updated.  We do need to redraw here. */
+	dollar_vcol = -1;
+
+	if (ccline.cmdindent > 0)
+	    disp_col += ccline.cmdindent - 1;
+	/* Compute the screen column of the start of the completed text.
+	 * Use the cursor to get all wrapping and other settings right. */
+	col = curwin->w_cursor.col;
+	curwin->w_cursor.col = clpum_compl_col;
+	clpum_display(clpum_compl_match_array, clpum_compl_match_arraysize, cur,
+									disp_col);
+	curwin->w_cursor.col = col;
+    }
+}
+
+/*
+ * Free the list of completions
+ */
+    static void
+clpum_compl_free(void)
+{
+    clpum_compl_T *match;
+    int	    i;
+
+    vim_free(clpum_compl_pattern);
+    clpum_compl_pattern = NULL;
+    vim_free(clpum_compl_leader);
+    clpum_compl_leader = NULL;
+
+    if (clpum_compl_first_match == NULL)
+	return;
+
+    clpum_compl_del_pum();
+    clpum_clear();
+
+    clpum_compl_curr_match = clpum_compl_first_match;
+    do
+    {
+	match = clpum_compl_curr_match;
+	clpum_compl_curr_match = clpum_compl_curr_match->cp_next;
+	vim_free(match->cp_str);
+	/* several entries may use the same fname, free it just once. */
+	if (match->cp_flags & FREE_FNAME)
+	    vim_free(match->cp_fname);
+	for (i = 0; i < CPT_COUNT; ++i)
+	    vim_free(match->cp_text[i]);
+	vim_free(match);
+    } while (clpum_compl_curr_match != NULL && clpum_compl_curr_match != clpum_compl_first_match);
+    clpum_compl_first_match = clpum_compl_curr_match = NULL;
+    clpum_compl_shown_match = NULL;
+}
+
+    static void
+clpum_compl_clear(void)
+{
+    clpum_compl_started = FALSE;
+    clpum_compl_matches = 0;
+    vim_free(clpum_compl_pattern);
+    clpum_compl_pattern = NULL;
+    vim_free(clpum_compl_leader);
+    clpum_compl_leader = NULL;
+    edit_submode_extra = NULL;
+    vim_free(clpum_compl_orig_text);
+    clpum_compl_orig_text = NULL;
+    clpum_compl_enter_selects = FALSE;
+    /* clear v:clcompleted_item */
+    set_vim_var_dict(VV_CLCOMPLETED_ITEM, dict_alloc());
+}
+
+/*
+ * Return TRUE when Insert completion is active.
+ */
+    int
+clpum_compl_active(void)
+{
+    return clpum_compl_started;
+}
+
+/*
+ * Delete one character before the cursor and show the subset of the matches
+ * that match the word that is now before the cursor.
+ * Returns the character to be used, NUL if the work is done and another char
+ * to be got from the user.
+ */
+    static int
+clpum_compl_bs(void)
+{
+    char_u	*p;
+    int		i, n;
+
+    n = ccline.cmdpos;
+    p = ccline.cmdbuff + ccline.cmdpos;
+    mb_ptr_back(ccline.cmdbuff, p);
+
+    /* Stop completion when the whole word was deleted.  For Omni completion
+     * allow the word to be deleted, we won't match everything. */
+    if ((int)(p - ccline.cmdbuff) - (int)clpum_compl_col <= 0)
+	return K_BS;
+
+    ccline.cmdpos = (int)(p - ccline.cmdbuff);
+    ccline.cmdlen -= n - ccline.cmdpos;
+    ccline.cmdspos -= n - ccline.cmdpos;
+    i = ccline.cmdpos;
+    while (i < ccline.cmdlen)
+	ccline.cmdbuff[i++] = ccline.cmdbuff[n++];
+
+    /* Truncate at the end, required for multi-byte chars. */
+    ccline.cmdbuff[ccline.cmdlen] = NUL;
+
+    /* Deleted more than what was used to find matches or didn't finish
+     * finding all matches: need to look for matches all over again. */
+    if (ccline.cmdpos <= clpum_compl_col + clpum_compl_length
+						  || clpum_compl_need_restart())
+	clpum_compl_restart(FALSE);
+
+    vim_free(clpum_compl_leader);
+    clpum_compl_leader = vim_strnsave(ccline.cmdbuff + clpum_compl_col,
+				(int)(p - ccline.cmdbuff) - clpum_compl_col);
+    if (clpum_compl_leader != NULL)
+    {
+	clpum_compl_new_leader();
+	if (clpum_compl_shown_match != NULL)
+	    /* Make sure current match is not a hidden item. */
+	    clpum_compl_curr_match = clpum_compl_shown_match;
+	return NUL;
+    }
+    return K_BS;
+}
+
+/*
+ * Return TRUE when we need to find matches again, clpum_compl_restart() is to
+ * be called.
+ */
+    static int
+clpum_compl_need_restart(void)
+{
+    /* Return TRUE if we didn't complete finding matches or when the
+     * 'completefunc' returned "always" in the "refresh" dictionary item. */
+    return clpum_compl_was_interrupted;
+}
+
+/*
+ * Called after changing "clpum_compl_leader".
+ * Show the popup menu with a different set of matches.
+ * May also search for matches again if the previous search was interrupted.
+ */
+    static void
+clpum_compl_new_leader(void)
+{
+    clpum_compl_del_pum();
+    clpum_compl_delete();
+    put_on_cmdline(clpum_compl_leader + clpum_compl_len(), -1, TRUE);
+
+    clpum_compl_used_match = FALSE;
+
+    if (clpum_compl_started)
+	clpum_compl_set_original_text(clpum_compl_leader);
+    else
+    {
+	/*
+	 * Matches were cleared, need to search for them now.  First display
+	 * the changed text before the cursor.  Set "clpum_compl_restarting" to
+	 * avoid that the first match is inserted.
+	 */
+	update_screen(0);
+#ifdef FEAT_GUI
+	if (gui.in_use)
+	{
+	    /* Show the cursor after the match, not after the redrawn text. */
+	    setcursor();
+	    out_flush();
+	    gui_update_cursor(FALSE, FALSE);
+	}
+#endif
+	clpum_compl_restarting = TRUE;
+	clpum_complete(Ctrl_N);
+	clpum_compl_restarting = FALSE;
+    }
+
+    clpum_compl_enter_selects = !clpum_compl_used_match;
+
+    /* Show the popup menu with a different set of matches. */
+    clpum_compl_show_pum();
+
+    /* Don't let Enter select the original text when there is no popup menu. */
+    if (clpum_compl_match_array == NULL)
+	clpum_compl_enter_selects = FALSE;
+}
+
+/*
+ * Return the length of the completion, from the completion start column to
+ * the cursor column.  Making sure it never goes below zero.
+ */
+    static int
+clpum_compl_len(void)
+{
+    int off = (int)ccline.cmdpos - (int)clpum_compl_col;
+
+    if (off < 0)
+	return 0;
+    return off;
+}
+
+/*
+ * Append one character to the match leader.  May reduce the number of
+ * matches.
+ */
+    static void
+clpum_compl_addleader(int c)
+{
+#ifdef FEAT_MBYTE
+    int		cc;
+
+    if (has_mbyte && (cc = (*mb_char2len)(c)) > 1)
+    {
+	char_u	buf[MB_MAXBYTES + 1];
+
+	(*mb_char2bytes)(c, buf);
+	buf[cc] = NUL;
+	put_on_cmdline(buf, -1, TRUE);
+    }
+    else
+#endif
+    {
+	char_u buf[2];
+
+	buf[0] = c;
+	buf[1] = NUL;
+	put_on_cmdline(buf, 1, TRUE);
+    }
+
+    /* If we didn't complete finding matches we must search again. */
+    if (clpum_compl_need_restart())
+	clpum_compl_restart(FALSE);
+
+    /* When 'always' is set, don't reset clpum_compl_leader. While completing,
+     * cursor doesn't point original position, changing clpum_compl_leader would
+     * break redo. */
+    if (!clpum_compl_opt_refresh_always)
+    {
+	vim_free(clpum_compl_leader);
+	clpum_compl_leader = vim_strnsave(ccline.cmdbuff + clpum_compl_col,
+				     (int)(ccline.cmdlen - clpum_compl_col));
+	if (clpum_compl_leader != NULL)
+	    clpum_compl_new_leader();
+    }
+}
+
+/*
+ * Setup for finding completions again without leaving CTRL-X mode.  Used when
+ * BS or a key was typed while still searching for matches.
+ */
+    static void
+clpum_compl_restart(int redraw)
+{
+    int		keytyped_save;
+
+    clpum_compl_free();
+    clpum_compl_started = FALSE;
+    clpum_compl_matches = 0;
+    clpum_compl_cont_mode = 0;
+
+    if (redraw)
+    {
+	redrawcmd();
+	keytyped_save = KeyTyped;
+	update_screen(0);
+	KeyTyped = keytyped_save;
+	cursorcmd();
+    }
+}
+
+/*
+ * Set the first match, the original text.
+ */
+    static void
+clpum_compl_set_original_text(char_u *str)
+{
+    char_u	*p;
+
+    /* Replace the original text entry. */
+    if (clpum_compl_first_match->cp_flags & ORIGINAL_TEXT)  /* safety check */
+    {
+	p = vim_strsave(str);
+	if (p != NULL)
+	{
+	    vim_free(clpum_compl_first_match->cp_str);
+	    clpum_compl_first_match->cp_str = p;
+	}
+    }
+}
+
+/*
+ * Append one character to the match leader.  May reduce the number of
+ * matches.
+ */
+    static void
+clpum_compl_addfrommatch(void)
+{
+    char_u	*p;
+    int		len = (int)ccline.cmdpos - (int)clpum_compl_col;
+    int		c;
+    clpum_compl_T	*cp;
+
+    p = clpum_compl_shown_match->cp_str;
+    if ((int)STRLEN(p) <= len)   /* the match is too short */
+    {
+	/* When still at the original match use the first entry that matches
+	 * the leader. */
+	if (clpum_compl_shown_match->cp_flags & ORIGINAL_TEXT)
+	{
+	    p = NULL;
+	    for (cp = clpum_compl_shown_match->cp_next; cp != NULL
+			    && cp != clpum_compl_first_match; cp = cp->cp_next)
+	    {
+		if (clpum_compl_leader == NULL
+			|| clpum_compl_equal(cp, clpum_compl_leader,
+					    (int)STRLEN(clpum_compl_leader)))
+		{
+		    p = cp->cp_str;
+		    break;
+		}
+	    }
+	    if (p == NULL || (int)STRLEN(p) <= len)
+		return;
+	}
+	else
+	    return;
+    }
+    p += len;
+    c = PTR2CHAR(p);
+    clpum_compl_addleader(c);
+}
+
+/*
+ * Prepare for Insert mode completion, or stop it.
+ * Called just after typing a character in Insert mode.
+ * Returns TRUE when the character is not to be inserted;
+ */
+    static int
+clpum_compl_prep(int c)
+{
+    int		retval = FALSE;
+    int		keytyped_save;
+
+    /* Forget any previous 'special' messages if this is actually
+     * a ^X mode key, in which case we wait to see what it gives us.
+     */
+    if (vim_is_clpum_key(c))
+	edit_submode_extra = NULL;
+
+    /* Ignore end of Select mode mapping and mouse scroll buttons. */
+    if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP
+	    || c == K_MOUSELEFT || c == K_MOUSERIGHT)
+	return retval;
+
+    if (!clpum_compl_started)
+	clpum_compl_used_match = TRUE;
+    else
+    {
+	if (c == Ctrl_X && !ctrl_x_mode)
+	    return TRUE;
+    }
+
+    if (!clpum_compl_started)
+    {
+	ctrl_x_mode = (c == Ctrl_X);
+	edit_submode = NULL;
+	showmode();
+    }
+    else
+    {
+	/* Show error message from attempted keyword completion (probably
+	 * 'Pattern not found') until another key is hit, then go back to
+	 * showing what mode we are in. */
+	if (!(c == p_wc && KeyTyped) && c != p_wcm && c != Ctrl_X
+		&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_D
+						     && !clpum_compl_pum_key(c))
+	{
+	    /* If the popup menu is displayed pressing CTRL-Y means accepting
+	     * the selection without inserting anything.  When
+	     * clpum_compl_enter_selects is set the Enter key does the same. */
+	    if ((c == Ctrl_Y || (clpum_compl_enter_selects
+				   && (c == CAR || c == K_KENTER || c == NL)))
+		    && clpum_visible())
+		retval = TRUE;
+
+	    /* CTRL-E means completion is Ended, go back to the typed text. */
+	    if (c == Ctrl_E)
+	    {
+		clpum_compl_delete();
+		if (clpum_compl_leader != NULL)
+		    put_on_cmdline(clpum_compl_leader + clpum_compl_len(), -1,
+									TRUE);
+		else if (clpum_compl_first_match != NULL)
+		    put_on_cmdline(clpum_compl_orig_text + clpum_compl_len(),
+								    -1, TRUE);
+		retval = TRUE;
+	    }
+
+	    clpum_compl_free();
+	    clpum_compl_started = FALSE;
+	    clpum_compl_matches = 0;
+	    if (!shortmess(SHM_COMPLETIONMENU))
+		msg_clr_cmdline();	/* necessary for "noshowmode" */
+	    ctrl_x_mode = 0;
+	    clpum_compl_enter_selects = FALSE;
+	    if (edit_submode != NULL)
+	    {
+		edit_submode = NULL;
+		showmode();
+	    }
+	    redrawcmd();
+	    keytyped_save = KeyTyped;
+	    update_screen(0);
+	    KeyTyped = keytyped_save;
+	    cursorcmd();
+
+#ifdef FEAT_AUTOCMD
+	    /* Trigger the ClCompleteDone event to give scripts a chance to act
+	     * upon the completion. */
+	    apply_autocmds(EVENT_CLCOMPLETEDONE, NULL, NULL, FALSE, curbuf);
+#endif
+	}
+    }
+
+    /* reset continue_* if we left expansion-mode, if we stay they'll be
+     * (re)set properly in clpum_complete() */
+    if (!vim_is_clpum_key(c))
+	clpum_compl_cont_mode = 0;
+
+    return retval;
+}
+
+#ifdef FEAT_CLPUM
+static void expand_by_function(char_u *base);
+
+/*
+ * Execute user defined complete function 'clcompletefunc' and
+ * get matches in "matches".
+ */
+    static void
+expand_by_function(char_u *base)
+{
+    list_T      *matchlist = NULL;
+    dict_T	*matchdict = NULL;
+    char_u	*args[2];
+    char_u	*funcname;
+    pos_T	pos;
+    win_T	*curwin_save;
+    buf_T	*curbuf_save;
+    typval_T	rettv;
+
+    funcname = p_clcfu;
+    if (*funcname == NUL)
+	return;
+
+    /* Call 'clcompletefunc' to obtain the list of matches. */
+    args[0] = (char_u *)"0";
+    args[1] = base;
+
+    pos = curwin->w_cursor;
+    curwin_save = curwin;
+    curbuf_save = curbuf;
+
+    /* Call a function, which returns a list or dict. */
+    if (call_vim_function(funcname, 2, args, FALSE, FALSE, &rettv) == OK)
+    {
+	switch (rettv.v_type)
+	{
+	    case VAR_LIST:
+		matchlist = rettv.vval.v_list;
+		break;
+	    case VAR_DICT:
+		matchdict = rettv.vval.v_dict;
+		break;
+	    default:
+		/* TODO: Give error message? */
+		clear_tv(&rettv);
+		break;
+	}
+    }
+
+    if (curwin_save != curwin || curbuf_save != curbuf)
+    {
+	EMSG(_(e_complwin));
+	goto theend;
+    }
+    curwin->w_cursor = pos;	/* restore the cursor position */
+    validate_cursor();
+    if (!equalpos(curwin->w_cursor, pos))
+    {
+	EMSG(_(e_compldel));
+	goto theend;
+    }
+
+    if (matchlist != NULL)
+	clpum_compl_add_list(matchlist);
+    else if (matchdict != NULL)
+	clpum_compl_add_dict(matchdict);
+
+theend:
+    if (matchdict != NULL)
+	dict_unref(matchdict);
+    if (matchlist != NULL)
+	list_unref(matchlist);
+}
+#endif /* FEAT_CLPUM */
+
+#if defined(FEAT_CLPUM) || defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Add completions from a list.
+ */
+    static void
+clpum_compl_add_list(list_T *list)
+{
+    listitem_T	*li;
+    int		dir = clpum_compl_direction;
+
+    /* Go through the List with matches and add each of them. */
+    for (li = list->lv_first; li != NULL; li = li->li_next)
+    {
+	if (clpum_compl_add_tv(&li->li_tv, dir) == OK)
+	    /* if dir was BACKWARD then honor it just once */
+	    dir = FORWARD;
+	else if (did_emsg)
+	    break;
+    }
+}
+
+/*
+ * Add completions from a dict.
+ */
+    static void
+clpum_compl_add_dict(dict_T *dict)
+{
+    dictitem_T	*di_refresh;
+    dictitem_T	*di_words;
+
+    /* Check for optional "refresh" item. */
+    clpum_compl_opt_refresh_always = FALSE;
+    di_refresh = dict_find(dict, (char_u *)"refresh", 7);
+    if (di_refresh != NULL && di_refresh->di_tv.v_type == VAR_STRING)
+    {
+	char_u	*v = di_refresh->di_tv.vval.v_string;
+
+	if (v != NULL && STRCMP(v, (char_u *)"always") == 0)
+	    clpum_compl_opt_refresh_always = TRUE;
+    }
+
+    /* Add completions from a "words" list. */
+    di_words = dict_find(dict, (char_u *)"words", 5);
+    if (di_words != NULL && di_words->di_tv.v_type == VAR_LIST)
+	clpum_compl_add_list(di_words->di_tv.vval.v_list);
+}
+
+/*
+ * Add a match to the list of matches from a typeval_T.
+ * If the given string is already in the list of completions, then return
+ * NOTDONE, otherwise add it to the list and return OK.  If there is an error,
+ * maybe because alloc() returns NULL, then FAIL is returned.
+ */
+    int
+clpum_compl_add_tv(typval_T *tv, int dir)
+{
+    char_u	*word;
+    int		icase = FALSE;
+    int		adup = FALSE;
+    int		aempty = FALSE;
+    char_u	*(cptext[CPT_COUNT]);
+
+    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
+    {
+	word = get_dict_string(tv->vval.v_dict, (char_u *)"word", FALSE);
+	cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict,
+						     (char_u *)"abbr", FALSE);
+	cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict,
+						     (char_u *)"menu", FALSE);
+	cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict,
+						     (char_u *)"kind", FALSE);
+	cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict,
+						     (char_u *)"info", FALSE);
+	if (get_dict_string(tv->vval.v_dict, (char_u *)"icase", FALSE) != NULL)
+	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
+	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
+	    adup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
+	if (get_dict_string(tv->vval.v_dict, (char_u *)"empty", FALSE) != NULL)
+	    aempty = get_dict_number(tv->vval.v_dict, (char_u *)"empty");
+    }
+    else
+    {
+	word = get_tv_string_chk(tv);
+	vim_memset(cptext, 0, sizeof(cptext));
+    }
+    if (word == NULL || (!aempty && *word == NUL))
+	return FAIL;
+    return clpum_compl_add(word, -1, icase, NULL, cptext, dir, 0, adup);
+}
+#endif
+
+/*
+ * Get the next expansion(s), using "clpum_compl_pattern".
+ * The search starts at position "ini" in curbuf and in the direction
+ * clpum_compl_direction.
+ * When "clpum_compl_started" is FALSE start at that position, otherwise continue
+ * where we stopped searching before.
+ * This may return before finding all the matches.
+ * Return the total number of matches or -1 if still unknown -- Acevedo
+ */
+    static int
+clpum_compl_get_exp(pos_T *ini UNUSED)
+{
+    char_u	**matches;
+    int		i;
+    int		num_matches;
+    int		found_new_match;
+    clpum_compl_T	*old_match;
+
+    old_match = clpum_compl_curr_match;	/* remember the last current match */
+    /* For ^N/^P loop over all the flags/windows/buffers in 'complete' */
+    for (;;)
+    {
+	found_new_match = FAIL;
+
+	if (ctrl_x_mode)
+	    expand_by_function(clpum_compl_pattern);
+	else
+	{
+	    if (expand_cmdline(clpum_compl_xp, clpum_compl_pattern,
+			(int)STRLEN(clpum_compl_pattern),
+					&num_matches, &matches) == EXPAND_OK)
+		clpum_compl_add_matches(num_matches, matches, FALSE);
+	}
+
+	/* check if clpum_compl_curr_match has changed, (e.g. other type of
+	 * expansion added something) */
+	if (clpum_compl_curr_match != old_match)
+	    found_new_match = OK;
+
+	/* break the loop for specialized modes (use 'complete' just for the
+	 * generic ctrl_x_mode == 0) or when we've found a new match */
+	if (got_int)
+	    break;
+	/* Fill the popup menu as soon as possible. */
+	clpum_compl_check_keys(0);
+
+	break;
+    }
+    clpum_compl_started = TRUE;
+    found_new_match = FAIL;
+
+    i = -1;		/* total of matches, unknown */
+    if (found_new_match == FAIL)
+	i = clpum_compl_make_cyclic();
+
+    /* If several matches were added (FORWARD) or the search failed and has
+     * just been made cyclic then we have to move clpum_compl_curr_match to the
+     * next or previous entry (if any) -- Acevedo */
+    clpum_compl_curr_match = clpum_compl_direction == FORWARD
+				    ? old_match->cp_next : old_match->cp_prev;
+    if (clpum_compl_curr_match == NULL)
+	clpum_compl_curr_match = old_match;
+    return i;
+}
+
+/* Delete the old text being completed. */
+    static void
+clpum_compl_delete(void)
+{
+    /* Delete the typed part. */
+    cmdline_del(clpum_compl_col);
+    /* clear v:clcompleted_item */
+    set_vim_var_dict(VV_CLCOMPLETED_ITEM, dict_alloc());
+}
+
+/* Insert the new text being completed. */
+    static void
+clpum_compl_insert(void)
+{
+    int		ret=OK, len;
+    dict_T	*dict;
+
+    len = (int)STRLEN(clpum_compl_shown_match->cp_str + clpum_compl_len());
+    if (ccline.cmdlen + len + 4 > ccline.cmdbufflen)
+	ret = realloc_cmdbuff(ccline.cmdlen + len + 4);
+    if (ret == OK)
+    {
+	mch_memmove(&ccline.cmdbuff[ccline.cmdpos + len],
+		&ccline.cmdbuff[ccline.cmdpos],
+		(size_t)(ccline.cmdlen - ccline.cmdpos + 1));
+	memcpy(&ccline.cmdbuff[ccline.cmdpos],
+		clpum_compl_shown_match->cp_str + clpum_compl_len(), len);
+	ccline.cmdlen += len;
+	ccline.cmdpos += len;
+    }
+
+    if (clpum_compl_shown_match->cp_flags & ORIGINAL_TEXT)
+	clpum_compl_used_match = FALSE;
+    else
+	clpum_compl_used_match = TRUE;
+
+    /* Set completed item. */
+    /* { word, abbr, menu, kind, info } */
+    dict = dict_alloc();
+    if (dict != NULL)
+    {
+	dict_add_nr_str(dict, "word", 0L,
+		    EMPTY_IF_NULL(clpum_compl_shown_match->cp_str));
+	dict_add_nr_str(dict, "abbr", 0L,
+		    EMPTY_IF_NULL(clpum_compl_shown_match->cp_text[CPT_ABBR]));
+	dict_add_nr_str(dict, "menu", 0L,
+		    EMPTY_IF_NULL(clpum_compl_shown_match->cp_text[CPT_MENU]));
+	dict_add_nr_str(dict, "kind", 0L,
+		    EMPTY_IF_NULL(clpum_compl_shown_match->cp_text[CPT_KIND]));
+	dict_add_nr_str(dict, "info", 0L,
+		    EMPTY_IF_NULL(clpum_compl_shown_match->cp_text[CPT_INFO]));
+    }
+    set_vim_var_dict(VV_CLCOMPLETED_ITEM, dict);
+}
+
+/*
+ * Fill in the next completion in the current direction.
+ * If "allow_get_expansion" is TRUE, then we may call clpum_compl_get_exp() to
+ * get more completions.  If it is FALSE, then we just do nothing when there
+ * are no more completions in a given direction.  The latter case is used when
+ * we are still in the middle of finding completions, to allow browsing
+ * through the ones found so far.
+ * Return the total number of matches, or -1 if still unknown -- webb.
+ *
+ * clpum_compl_curr_match is currently being used by clpum_compl_get_exp(), so
+ * we use clpum_compl_shown_match here.
+ *
+ * Note that this function may be called recursively once only.  First with
+ * "allow_get_expansion" TRUE, which calls clpum_compl_get_exp(), which in turn
+ * calls this function with "allow_get_expansion" FALSE.
+ */
+    static int
+clpum_compl_next(
+    int	    allow_get_expansion,
+    int	    count,		/* repeat completion this many times; should
+				   be at least 1 */
+    int	    insert_match)	/* Insert the newly selected match */
+{
+    int	    num_matches = -1;
+    int	    i;
+    int	    todo = count;
+    clpum_compl_T *found_compl = NULL;
+    int	    found_end = FALSE;
+    int	    advance = TRUE;
+    int	    started = clpum_compl_started;
+
+    /* When user complete function return -1 for findstart which is next
+     * time of 'always', clpum_compl_shown_match become NULL. */
+    if (clpum_compl_shown_match == NULL)
+	return -1;
+
+    if (clpum_compl_leader != NULL
+		    && (clpum_compl_shown_match->cp_flags & ORIGINAL_TEXT) == 0)
+    {
+	/* Set "clpum_compl_shown_match" to the actually shown match, it may
+	 * differ when "clpum_compl_leader" is used to omit some of the
+	 * matches. */
+	while (!clpum_compl_equal(clpum_compl_shown_match,
+			    clpum_compl_leader, (int)STRLEN(clpum_compl_leader))
+		&& clpum_compl_shown_match->cp_next != NULL
+		&& clpum_compl_shown_match->cp_next != clpum_compl_first_match)
+	    clpum_compl_shown_match = clpum_compl_shown_match->cp_next;
+
+	/* If we didn't find it searching forward, and clpum_compl_shows_dir is
+	 * backward, find the last match. */
+	if (clpum_compl_shows_dir == BACKWARD
+		&& !clpum_compl_equal(clpum_compl_shown_match,
+				      clpum_compl_leader,
+				      (int)STRLEN(clpum_compl_leader))
+		&& (clpum_compl_shown_match->cp_next == NULL
+		    || clpum_compl_shown_match->cp_next
+						    == clpum_compl_first_match))
+	{
+	    while (!clpum_compl_equal(clpum_compl_shown_match,
+				      clpum_compl_leader,
+				      (int)STRLEN(clpum_compl_leader))
+		    && clpum_compl_shown_match->cp_prev != NULL
+		    && clpum_compl_shown_match->cp_prev
+						    != clpum_compl_first_match)
+		clpum_compl_shown_match = clpum_compl_shown_match->cp_prev;
+	}
+    }
+
+    if (allow_get_expansion && insert_match
+	    && (!clpum_compl_restarting || clpum_compl_used_match))
+	/* Delete old text to be replaced */
+	clpum_compl_delete();
+
+    /* When restarting the search don't insert the first match either. */
+    if (clpum_compl_restarting)
+    {
+	advance = FALSE;
+	clpum_compl_restarting = FALSE;
+    }
+
+    /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap
+     * around. */
+    while (--todo >= 0)
+    {
+	if (clpum_compl_shows_dir == FORWARD
+				    && clpum_compl_shown_match->cp_next != NULL)
+	{
+	    clpum_compl_shown_match = clpum_compl_shown_match->cp_next;
+	    found_end = (clpum_compl_first_match != NULL
+		&& (clpum_compl_shown_match->cp_next == clpum_compl_first_match
+			|| clpum_compl_shown_match == clpum_compl_first_match));
+	}
+	else if (clpum_compl_shows_dir == BACKWARD
+				    && clpum_compl_shown_match->cp_prev != NULL)
+	{
+	    found_end = (clpum_compl_shown_match == clpum_compl_first_match);
+	    clpum_compl_shown_match = clpum_compl_shown_match->cp_prev;
+	    found_end |= (clpum_compl_shown_match == clpum_compl_first_match);
+	}
+	else
+	{
+	    if (!allow_get_expansion)
+	    {
+		if (advance)
+		{
+		    if (clpum_compl_shows_dir == BACKWARD)
+			clpum_compl_pending -= todo + 1;
+		    else
+			clpum_compl_pending += todo + 1;
+		}
+		return -1;
+	    }
+
+	    if (!clpum_compl_no_select && advance)
+	    {
+		if (clpum_compl_shows_dir == BACKWARD)
+		    --clpum_compl_pending;
+		else
+		    ++clpum_compl_pending;
+	    }
+
+	    /* Find matches. */
+	    num_matches = clpum_compl_get_exp(&clpum_compl_startpos);
+
+	    /* handle any pending completions */
+	    while (clpum_compl_pending != 0
+			    && clpum_compl_direction == clpum_compl_shows_dir
+								   && advance)
+	    {
+		if (clpum_compl_pending > 0
+				    && clpum_compl_shown_match->cp_next != NULL)
+		{
+		    clpum_compl_shown_match = clpum_compl_shown_match->cp_next;
+		    --clpum_compl_pending;
+		}
+		if (clpum_compl_pending < 0
+				    && clpum_compl_shown_match->cp_prev != NULL)
+		{
+		    clpum_compl_shown_match = clpum_compl_shown_match->cp_prev;
+		    ++clpum_compl_pending;
+		}
+		else
+		    break;
+	    }
+	    found_end = FALSE;
+	}
+	if ((clpum_compl_shown_match->cp_flags & ORIGINAL_TEXT) == 0
+		&& clpum_compl_leader != NULL
+		&& !clpum_compl_equal(clpum_compl_shown_match,
+				     clpum_compl_leader,
+				     (int)STRLEN(clpum_compl_leader)))
+	    ++todo;
+	else
+	    /* Remember a matching item. */
+	    found_compl = clpum_compl_shown_match;
+
+	/* Stop at the end of the list when we found a usable match. */
+	if (found_end)
+	{
+	    if (found_compl != NULL)
+	    {
+		clpum_compl_shown_match = found_compl;
+		break;
+	    }
+	    todo = 1;	    /* use first usable match after wrapping around */
+	}
+    }
+
+    /* Insert the text of the new completion, or the clpum_compl_leader. */
+    if (clpum_compl_no_insert && !started)
+    {
+	put_on_cmdline(clpum_compl_orig_text + clpum_compl_len(), -1, TRUE);
+	clpum_compl_used_match = FALSE;
+    }
+    else if (insert_match)
+	clpum_compl_insert();
+    else
+	clpum_compl_used_match = FALSE;
+
+    if (!allow_get_expansion)
+    {
+	/* may undisplay the popup menu first */
+	clpum_compl_upd_pum();
+
+	/* redraw to show the user what was inserted */
+	update_screen(0);
+
+	/* display the updated popup menu */
+	clpum_compl_show_pum();
+#ifdef FEAT_GUI
+	if (gui.in_use)
+	{
+	    /* Show the cursor after the match, not after the redrawn text. */
+	    setcursor();
+	    out_flush();
+	    gui_update_cursor(FALSE, FALSE);
+	}
+#endif
+
+	/* Delete old text to be replaced, since we're still searching and
+	 * don't want to match ourselves!  */
+	clpum_compl_delete();
+    }
+
+    /* Enter will select a match when the match wasn't inserted and the popup
+     * menu is visible. */
+    if (clpum_compl_no_insert && !started)
+	clpum_compl_enter_selects = TRUE;
+    else
+	clpum_compl_enter_selects = !insert_match && clpum_compl_match_array
+								    != NULL;
+
+    /*
+     * Show the file name for the match (if any)
+     * Truncate the file name to avoid a wait for return.
+     */
+    if (clpum_compl_shown_match->cp_fname != NULL)
+    {
+	STRCPY(IObuff, "match in file ");
+	i = (vim_strsize(clpum_compl_shown_match->cp_fname) + 16) - sc_col;
+	if (i <= 0)
+	    i = 0;
+	else
+	    STRCAT(IObuff, "<");
+	STRCAT(IObuff, clpum_compl_shown_match->cp_fname + i);
+	msg(IObuff);
+	redraw_cmdline = FALSE;	    /* don't overwrite! */
+    }
+
+    return num_matches;
+}
+
+/*
+ * Call this while finding completions, to check whether the user has hit a key
+ * that should change the currently displayed completion, or exit completion
+ * mode.  Also, when clpum_compl_pending is not zero, show a completion as soon
+ * as possible. -- webb
+ * "frequency" specifies out of how many calls we actually check.
+ */
+    void
+clpum_compl_check_keys(int frequency)
+{
+    static int	count = 0;
+
+    int	    c;
+
+    /* Don't check when reading keys from a script.  That would break the test
+     * scripts */
+    if (using_script())
+	return;
+
+    /* Only do this at regular intervals */
+    if (++count < frequency)
+	return;
+    count = 0;
+
+    /* Check for a typed key.  Do use mappings, otherwise vim_is_clpum_key()
+     * can't do its work correctly. */
+    c = vpeekc_any();
+    if (c != NUL)
+    {
+	if (vim_is_clpum_key(c) && c != Ctrl_X)
+	{
+	    c = safe_vgetc();	/* Eat the character */
+	    clpum_compl_shows_dir = clpum_compl_key2dir(c);
+	    (void)clpum_compl_next(FALSE, clpum_compl_key2count(c),
+						    c != K_UP && c != K_DOWN);
+	}
+	else
+	{
+	    /* Need to get the character to have KeyTyped set.  We'll put it
+	     * back with vungetc() below.  But skip K_IGNORE. */
+	    c = safe_vgetc();
+	    if (c != K_IGNORE)
+	    {
+		/* Don't interrupt completion when the character wasn't typed,
+		 * e.g., when doing @q to replay keys. */
+		if (KeyTyped)
+		    clpum_compl_interrupted = TRUE;
+
+		vungetc(c);
+	    }
+	}
+    }
+    if (clpum_compl_pending != 0 && !got_int && !clpum_compl_no_insert)
+    {
+	int todo = clpum_compl_pending > 0 ? clpum_compl_pending
+							: -clpum_compl_pending;
+
+	clpum_compl_pending = 0;
+	(void)clpum_compl_next(FALSE, todo, TRUE);
+    }
+}
+
+/*
+ * Decide the direction of Insert mode complete from the key typed.
+ * Returns BACKWARD or FORWARD.
+ */
+    static int
+clpum_compl_key2dir(int c)
+{
+    if (c == Ctrl_P
+	    || (clpum_visible() && (c == K_PAGEUP || c == K_KPAGEUP
+						|| c == K_S_UP || c == K_UP)))
+	return BACKWARD;
+    return FORWARD;
+}
+
+/*
+ * Return TRUE for keys that are used for completion only when the popup menu
+ * is visible.
+ */
+    static int
+clpum_compl_pum_key(int c)
+{
+    return clpum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP
+		     || c == K_PAGEDOWN || c == K_KPAGEDOWN || c == K_S_DOWN
+		     || c == K_UP || c == K_DOWN);
+}
+
+/*
+ * Decide the number of completions to move forward.
+ * Returns 1 for most keys, height of the popup menu for page-up/down keys.
+ */
+    static int
+clpum_compl_key2count(int c)
+{
+    int		h;
+
+    if (clpum_compl_pum_key(c) && c != K_UP && c != K_DOWN)
+    {
+	h = clpum_get_height();
+	if (h > 3)
+	    h -= 2; /* keep some context */
+	return h;
+    }
+    return 1;
+}
+
+/*
+ * Return TRUE if completion with "c" should insert the match, FALSE if only
+ * to change the currently selected completion.
+ */
+    static int
+clpum_compl_use_match(int c)
+{
+    switch (c)
+    {
+	case K_UP:
+	case K_DOWN:
+	case K_PAGEDOWN:
+	case K_KPAGEDOWN:
+	case K_S_DOWN:
+	case K_PAGEUP:
+	case K_KPAGEUP:
+	case K_S_UP:
+	    return FALSE;
+    }
+    return TRUE;
+}
+
+/*
+ * Do a Command-line popup completion.
+ * Called when character "c" was typed, which has a meaning for completion.
+ * Returns OK if completion was done, FAIL if something failed (out of mem).
+ */
+    static int
+clpum_complete(int c)
+{
+    int		n;
+    int		save_cl_row;
+
+    clpum_compl_direction = clpum_compl_key2dir(c);
+    if (!clpum_compl_started)
+    {
+	/* First time we hit ^N or ^P (in a row, I mean) */
+
+	clpum_compl_pending = 0;
+
+	clpum_compl_startpos.col = ccline.cmdpos;
+	clpum_compl_col = 0;
+
+	clpum_compl_pattern = vim_strnsave(ccline.cmdbuff, ccline.cmdpos);
+	if (clpum_compl_pattern == NULL)
+	    return FAIL;
+	set_cmd_context(clpum_compl_xp, clpum_compl_pattern,
+			    (int)STRLEN(clpum_compl_pattern), ccline.cmdpos);
+	if (ccline.input_fn)
+	    clpum_compl_xp->xp_pattern = clpum_compl_pattern;
+	if (clpum_compl_xp->xp_context == EXPAND_UNSUCCESSFUL
+		|| clpum_compl_xp->xp_context == EXPAND_NOTHING)
+	    /* No completion possible, use an empty pattern to get a
+		* "pattern not found" message. */
+	    clpum_compl_col = ccline.cmdpos;
+	else
+	    clpum_compl_col = (int)(clpum_compl_xp->xp_pattern
+							- clpum_compl_pattern);
+	clpum_compl_length = ccline.cmdpos - clpum_compl_col;
+	clpum_compl_startpos.col = clpum_compl_col;
+	if (ctrl_x_mode)
+	{
+	    /*
+	     * Call user defined function 'clcompletefunc' with "a:findstart"
+	     * set to 1 to obtain the length of text to use for completion.
+	     */
+	    char_u	*args[2];
+	    int		col;
+	    pos_T	pos;
+	    win_T	*curwin_save;
+	    buf_T	*curbuf_save;
+
+	    /* Call 'clcompletefunc' and get pattern length as a string */
+	    if (*p_clcfu == NUL)
+	    {
+		EMSG2(_(e_notset), "clcompletefunc");
+		return FAIL;
+	    }
+
+	    args[0] = (char_u *)"1";
+	    args[1] = NULL;
+	    pos = curwin->w_cursor;
+	    curwin_save = curwin;
+	    curbuf_save = curbuf;
+	    col = call_func_retnr(p_clcfu, 2, args, FALSE);
+	    if (curwin_save != curwin || curbuf_save != curbuf)
+	    {
+		EMSG(_(e_complwin));
+		return FAIL;
+	    }
+	    curwin->w_cursor = pos;	/* restore the cursor position */
+	    validate_cursor();
+	    if (!equalpos(curwin->w_cursor, pos))
+	    {
+		EMSG(_(e_compldel));
+		return FAIL;
+	    }
+
+	    /* Return value -2 means the user complete function wants to
+	     * cancel the complete without an error.
+	     * Return value -3 does the same as -2 and leaves CTRL-X mode.*/
+	    if (col == -2 || col == -3)
+	    {
+		ctrl_x_mode = 0;
+		edit_submode = NULL;
+		if (!shortmess(SHM_COMPLETIONMENU))
+		    msg_clr_cmdline();
+		return FAIL;
+	    }
+
+	    /*
+	     * Reset extended parameters of completion, when start new
+	     * completion.
+	     */
+	    clpum_compl_opt_refresh_always = FALSE;
+
+	    if (col < 0)
+		col = ccline.cmdpos;
+	    clpum_compl_col = col;
+	    if (clpum_compl_col > ccline.cmdpos)
+		clpum_compl_col = ccline.cmdpos;
+
+	    /* Setup variables for completion.  Need to obtain "line" again,
+	     * it may have become invalid. */
+	    clpum_compl_length = ccline.cmdpos - clpum_compl_col;
+	    clpum_compl_pattern = vim_strnsave(ccline.cmdbuff + clpum_compl_col,
+							clpum_compl_length);
+	    if (clpum_compl_pattern == NULL)
+		return FAIL;
+
+	    edit_submode = (char_u *)_(" Command-line mode User defined "
+					"completion (^X^N^P)");
+	}
+	else
+	    edit_submode = (char_u *)_(" Command-line mode completion "
+					"(^N^P)");
+
+	/* Always add completion for the original text. */
+	vim_free(clpum_compl_orig_text);
+	clpum_compl_orig_text = vim_strnsave(ccline.cmdbuff + clpum_compl_col,
+							    clpum_compl_length);
+	if (clpum_compl_orig_text == NULL
+		|| clpum_compl_add(clpum_compl_orig_text, -1, p_ic, NULL, NULL,
+						0, ORIGINAL_TEXT, FALSE) != OK)
+	{
+	    vim_free(clpum_compl_pattern);
+	    clpum_compl_pattern = NULL;
+	    vim_free(clpum_compl_orig_text);
+	    clpum_compl_orig_text = NULL;
+	    return FAIL;
+	}
+
+	/* showmode might reset the internal line pointers, so it must
+	 * be called before line = ml_get(), or when this address is no
+	 * longer needed.  -- Acevedo.
+	 */
+	edit_submode_extra = (char_u *)_("-- Searching...");
+	edit_submode_highl = HLF_COUNT;
+	clpum_compl_started = TRUE;
+	showmode();
+	clpum_compl_started = FALSE;
+	edit_submode_extra = NULL;
+	out_flush();
+    }
+
+    clpum_compl_shown_match = clpum_compl_curr_match;
+    clpum_compl_shows_dir = clpum_compl_direction;
+
+    /*
+     * Find next match (and following matches).
+     */
+    save_cl_row = cmdline_row;
+    n = clpum_compl_next(TRUE, clpum_compl_key2count(c),
+						    clpum_compl_use_match(c));
+
+    /* may undisplay the popup menu */
+    clpum_compl_upd_pum();
+
+    if (n > 1)		/* all matches have been found */
+	clpum_compl_matches = n;
+    clpum_compl_curr_match = clpum_compl_shown_match;
+    clpum_compl_direction = clpum_compl_shows_dir;
+
+    /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert
+     * mode. */
+    if (got_int && !global_busy)
+    {
+	(void)vgetc();
+	got_int = FALSE;
+    }
+
+    /* we found no match if the list has only the "clpum_compl_orig_text"-entry
+     */
+    if (clpum_compl_first_match == clpum_compl_first_match->cp_next)
+    {
+	edit_submode_extra = (char_u *)_(e_patnotf);
+	edit_submode_highl = HLF_E;
+    }
+
+    if (edit_submode_extra == NULL)
+    {
+	if (clpum_compl_curr_match->cp_flags & ORIGINAL_TEXT)
+	{
+	    edit_submode_extra = (char_u *)_("Back at original");
+	    edit_submode_highl = HLF_W;
+	}
+	else if (clpum_compl_curr_match->cp_next
+					    == clpum_compl_curr_match->cp_prev)
+	{
+	    edit_submode_extra = (char_u *)_("The only match");
+	    edit_submode_highl = HLF_COUNT;
+	}
+	else
+	{
+	    /* Update completion sequence number when needed. */
+	    if (clpum_compl_curr_match->cp_number == -1)
+	    {
+		int		number = 0;
+		clpum_compl_T		*match;
+
+		if (clpum_compl_direction == FORWARD)
+		{
+		    /* search backwards for the first valid (!= -1) number.
+		     * This should normally succeed already at the first loop
+		     * cycle, so it's fast! */
+		    for (match = clpum_compl_curr_match->cp_prev; match != NULL
+			    && match != clpum_compl_first_match;
+						       match = match->cp_prev)
+			if (match->cp_number != -1)
+			{
+			    number = match->cp_number;
+			    break;
+			}
+		    if (match != NULL)
+			/* go up and assign all numbers which are not assigned
+			 * yet */
+			for (match = match->cp_next;
+				match != NULL && match->cp_number == -1;
+						       match = match->cp_next)
+			    match->cp_number = ++number;
+		}
+		else /* BACKWARD */
+		{
+		    /* search forwards (upwards) for the first valid (!= -1)
+		     * number.  This should normally succeed already at the
+		     * first loop cycle, so it's fast! */
+		    for (match = clpum_compl_curr_match->cp_next; match != NULL
+			    && match != clpum_compl_first_match;
+						       match = match->cp_next)
+			if (match->cp_number != -1)
+			{
+			    number = match->cp_number;
+			    break;
+			}
+		    if (match != NULL)
+			/* go down and assign all numbers which are not
+			 * assigned yet */
+			for (match = match->cp_prev; match
+				&& match->cp_number == -1;
+						       match = match->cp_prev)
+			    match->cp_number = ++number;
+		}
+	    }
+
+	    /* The match should always have a sequence number now, this is
+	     * just a safety check. */
+	    if (clpum_compl_curr_match->cp_number != -1)
+	    {
+		/* Space for 10 text chars. + 2x10-digit no.s = 31.
+		 * Translations may need more than twice that. */
+		static char_u match_ref[81];
+
+		if (clpum_compl_matches > 0)
+		    vim_snprintf((char *)match_ref, sizeof(match_ref),
+				_("match %d of %d"),
+				clpum_compl_curr_match->cp_number,
+				clpum_compl_matches);
+		else
+		    vim_snprintf((char *)match_ref, sizeof(match_ref),
+				_("match %d"),
+				clpum_compl_curr_match->cp_number);
+		edit_submode_extra = match_ref;
+		edit_submode_highl = HLF_R;
+	    }
+	}
+    }
+
+    /* Show a message about what (completion) mode we're in. */
+    showmode();
+    if (!shortmess(SHM_COMPLETIONMENU))
+    {
+	if (edit_submode_extra != NULL)
+	{
+	    if (!p_smd)
+		msg_attr(edit_submode_extra,
+			edit_submode_highl < HLF_COUNT
+			? hl_attr(edit_submode_highl) : 0);
+	}
+	else
+	    msg_clr_cmdline();	/* necessary for "noshowmode" */
+    }
+
+    /* Show the popup menu, unless we got interrupted. */
+    if (!clpum_compl_interrupted)
+    {
+	/* RedrawingDisabled may be set when invoked through complete(). */
+	n = RedrawingDisabled;
+	RedrawingDisabled = 0;
+
+	/* If the cursor moved we need to remove the pum first. */
+	setcursor();
+	if (save_cl_row != cmdline_row)
+	    clpum_compl_del_pum();
+
+	clpum_compl_show_pum();
+	setcursor();
+	RedrawingDisabled = n;
+    }
+    clpum_compl_was_interrupted = clpum_compl_interrupted;
+    clpum_compl_interrupted = FALSE;
+
+    return OK;
+}
+
+#endif
diff --git a/src/feature.h b/src/feature.h
index 2a090ab..2ab0283 100644
--- a/src/feature.h
+++ b/src/feature.h
@@ -496,6 +496,13 @@
 #endif
 
 /*
+ * +clpum		Command-line PopUp Menu
+ */
+#if defined(FEAT_NORMAL) && defined(FEAT_WILDMENU)
+# define FEAT_CLPUM
+#endif
+
+/*
  * +viminfo		reading/writing the viminfo file. Takes about 8Kbyte
  *			of code.
  * VIMINFO_FILE		Location of user .viminfo file (should start with $).
diff --git a/src/fileio.c b/src/fileio.c
index fa927ff..6dc4d0d 100644
--- a/src/fileio.c
+++ b/src/fileio.c
@@ -7648,6 +7648,7 @@ static struct event_name
     {"BufWritePost",	EVENT_BUFWRITEPOST},
     {"BufWritePre",	EVENT_BUFWRITEPRE},
     {"BufWriteCmd",	EVENT_BUFWRITECMD},
+    {"ClCompleteDone",	EVENT_CLCOMPLETEDONE},
     {"CmdwinEnter",	EVENT_CMDWINENTER},
     {"CmdwinLeave",	EVENT_CMDWINLEAVE},
     {"CmdUndefined",	EVENT_CMDUNDEFINED},
@@ -7711,9 +7712,9 @@ static struct event_name
     {"VimEnter",	EVENT_VIMENTER},
     {"VimLeave",	EVENT_VIMLEAVE},
     {"VimLeavePre",	EVENT_VIMLEAVEPRE},
+    {"VimResized",	EVENT_VIMRESIZED},
     {"WinEnter",	EVENT_WINENTER},
     {"WinLeave",	EVENT_WINLEAVE},
-    {"VimResized",	EVENT_VIMRESIZED},
     {NULL,		(event_T)0}
 };
 
diff --git a/src/globals.h b/src/globals.h
index 9771116..5a614db 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -140,6 +140,20 @@ EXTERN int	compl_cont_status INIT(= 0);
 				 * expansion, (eg use complete=.) */
 #endif
 
+#ifdef FEAT_CLPUM
+/*
+ * Variables for Command-line mode completion.
+ */
+
+/* Length in bytes of the text being completed (this is deleted to be replaced
+ * by the match.) */
+EXTERN int	clpum_compl_length INIT(= 0);
+
+/* Set when character typed while looking for matches and it means we should
+ * stop looking for matches. */
+EXTERN int	clpum_compl_interrupted INIT(= FALSE);
+#endif
+
 /*
  * Functions for putting characters in the command line,
  * while keeping ScreenLines[] updated.
@@ -947,7 +961,7 @@ EXTERN int arrow_used;			/* Normally FALSE, set to TRUE after
 					 * to call u_sync() */
 EXTERN int	ins_at_eol INIT(= FALSE); /* put cursor after eol when
 					   restarting edit after CTRL-O */
-#ifdef FEAT_INS_EXPAND
+#if defined(FEAT_INS_EXPAND) || defined(FEAT_CLPUM)
 EXTERN char_u	*edit_submode INIT(= NULL); /* msg for CTRL-X submode */
 EXTERN char_u	*edit_submode_pre INIT(= NULL); /* prepended to edit_submode */
 EXTERN char_u	*edit_submode_extra INIT(= NULL);/* appended to edit_submode */
@@ -1581,7 +1595,7 @@ EXTERN char_u e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
 
 EXTERN char_u e_invalpat[]	INIT(= N_("E682: Invalid search pattern or delimiter"));
 EXTERN char_u e_bufloaded[]	INIT(= N_("E139: File is loaded in another buffer"));
-#if defined(FEAT_SYN_HL) || \
+#if defined(FEAT_SYN_HL) || defined(FEAT_CMDL_COMPL) || \
 	(defined(FEAT_INS_EXPAND) && defined(FEAT_COMPL_FUNC))
 EXTERN char_u e_notset[]	INIT(= N_("E764: Option '%s' is not set"));
 #endif
diff --git a/src/gui.c b/src/gui.c
index d4fd68a..b100940 100644
--- a/src/gui.c
+++ b/src/gui.c
@@ -3971,6 +3971,12 @@ gui_drag_scrollbar(scrollbar_T *sb, long value, int still_dragging)
     if ((sb->wp == NULL || sb->wp == curwin) && pum_visible())
 	return;
 #endif
+#ifdef FEAT_CLPUM
+    /* Disallow scrolling the current window when the command-line completion
+     * popup menu is visible. */
+    if (clpum_visible())
+	return;
+#endif
 
 #ifdef FEAT_RIGHTLEFT
     if (sb->wp == NULL && curwin->w_p_rl)
@@ -4456,13 +4462,18 @@ gui_do_scroll(void)
     {
 	int type = VALID;
 
+	if (0
 #ifdef FEAT_INS_EXPAND
-	if (pum_visible())
+		|| pum_visible()
+#endif
+#ifdef FEAT_CLPUM
+		|| clpum_visible()
+#endif
+	   )
 	{
 	    type = NOT_VALID;
 	    wp->w_lines_valid = 0;
 	}
-#endif
 	/* Don't set must_redraw here, it may cause the popup menu to
 	 * disappear when losing focus after a scrollbar drag. */
 	if (wp->w_redr_type < type)
@@ -4475,6 +4486,11 @@ gui_do_scroll(void)
     if (pum_visible())
 	pum_redraw();
 #endif
+#ifdef FEAT_CLPUM
+    /* May need to redraw the command-line popup menu. */
+    if (clpum_visible())
+	clpum_redraw();
+#endif
 
     return (wp == curwin && !equalpos(curwin->w_cursor, old_cursor));
 }
diff --git a/src/main.aap b/src/main.aap
index 452cd97..7f944fc 100644
--- a/src/main.aap
+++ b/src/main.aap
@@ -293,6 +293,7 @@ Source =
         blowfish.c
         buffer.c
         charset.c
+        clpum.c
         diff.c
         digraph.c
         edit.c
diff --git a/src/message.c b/src/message.c
index f793ed4..2ebf5f2 100644
--- a/src/message.c
+++ b/src/message.c
@@ -1976,6 +1976,11 @@ msg_puts_display(
 	    if (cmdline_row > 0 && !exmode_active)
 		--cmdline_row;
 
+#ifdef FEAT_CLPUM
+	    if (clpum_visible())
+		continue;
+#endif
+
 	    /*
 	     * If screen is completely filled and 'more' is set then wait
 	     * for a character.
diff --git a/src/move.c b/src/move.c
index 1a00a4d..f0814ea 100644
--- a/src/move.c
+++ b/src/move.c
@@ -136,9 +136,12 @@ redraw_for_cursorline(win_T *wp)
 #endif
 		)
 	    && (wp->w_valid & VALID_CROW) == 0
-# ifdef FEAT_INS_EXPAND
+#ifdef FEAT_INS_EXPAND
 	    && !pum_visible()
-# endif
+#endif
+#ifdef FEAT_CLPUM
+	    && !clpum_visible()
+#endif
 	    )
 	redraw_win_later(wp, SOME_VALID);
 }
@@ -812,6 +815,9 @@ validate_virtcol_win(win_T *wp)
 # ifdef FEAT_INS_EXPAND
 		&& !pum_visible()
 # endif
+# ifdef FEAT_CLPUM
+		&& !clpum_visible()
+# endif
 		)
 	    redraw_win_later(wp, SOME_VALID);
 #endif
@@ -1183,6 +1189,9 @@ curs_columns(
 # ifdef FEAT_INS_EXPAND
 	    && !pum_visible()
 # endif
+# ifdef FEAT_CLPUM
+	    && !clpum_visible()
+# endif
 	)
 	redraw_later(SOME_VALID);
 #endif
diff --git a/src/option.c b/src/option.c
index 95f4c73..d52e0cc 100644
--- a/src/option.c
+++ b/src/option.c
@@ -466,9 +466,10 @@ struct vimoption
 
 /* Make the string as short as possible when compiling with few features. */
 #if defined(FEAT_DIFF) || defined(FEAT_FOLDING) || defined(FEAT_SPELL) \
-	|| defined(FEAT_WINDOWS) || defined(FEAT_CLIPBOARD) \
-	|| defined(FEAT_INS_EXPAND) || defined(FEAT_SYN_HL) || defined(FEAT_CONCEAL)
-# define HIGHLIGHT_INIT "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,!:CursorColumn,.:CursorLine,o:ColorColumn"
+	|| defined(FEAT_VERTSPLIT) || defined(FEAT_CLIPBOARD) \
+	|| defined(FEAT_INS_EXPAND) || defined(FEAT_SYN_HL) \
+	|| defined(FEAT_CONCEAL) || defined(FEAT_CLPUM)
+# define HIGHLIGHT_INIT "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,x:PmenuSbar,X:PmenuThumb,0:ClPmenu,1:ClPmenuSel,y:ClPmenuSbar,Y:ClPmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,!:CursorColumn,.:CursorLine,o:ColorColumn"
 #else
 # define HIGHLIGHT_INIT "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,w:WarningMsg,W:WildMenu,>:SignColumn,*:TabLine,#:TabLineSel,_:TabLineFill"
 #endif
@@ -781,6 +782,31 @@ static struct vimoption options[] =
 			    {(char_u *)"", (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+    {"clcompletefunc", "clcfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
+#ifdef FEAT_CLPUM
+			    (char_u *)&p_clcfu, PV_NONE,
+			    {(char_u *)"", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+    {"clcompleteopt", "clcot", P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP,
+#ifdef FEAT_CLPUM
+			    (char_u *)&p_clcot, PV_NONE,
+			    {(char_u *)"menuone,noinsert", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+    {"clpumheight", "clph", P_NUM|P_VI_DEF,
+#ifdef FEAT_CLPUM
+			    (char_u *)&p_clph, PV_NONE,
+#else
+			    (char_u *)NULL, PV_NONE,
+#endif
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ch, PV_NONE,
 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
@@ -3035,6 +3061,9 @@ static struct vimoption options[] =
 static char *(p_ambw_values[]) = {"single", "double", NULL};
 #endif
 static char *(p_bg_values[]) = {"light", "dark", NULL};
+#ifdef FEAT_CLPUM
+static char *(p_clcot_values[]) = {"menu", "menuone", "noinsert", "noselect", NULL};
+#endif
 static char *(p_nf_values[]) = {"bin", "octal", "hex", "alpha", NULL};
 static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};
 #ifdef FEAT_CRYPT
@@ -5942,6 +5971,17 @@ did_set_string_option(
 	}
     }
 
+#ifdef FEAT_CLPUM
+    /* 'clcompleteopt' */
+    else if (varp == &p_clcot)
+    {
+	if (check_opt_strings(p_clcot, p_clcot_values, TRUE) != OK)
+	    errmsg = e_invarg;
+	else
+	    clpum_completeopt_was_set();
+    }
+#endif
+
 #ifdef FEAT_SYN_HL
     /* 'colorcolumn' */
     else if (varp == &curwin->w_p_cc)
@@ -11970,35 +12010,51 @@ opt_strings_flags(
 check_opt_wim(void)
 {
     char_u	new_wim_flags[4];
-    char_u	*p;
+    char_u	*p = p_wim;
     int		i;
     int		idx = 0;
+    int		len;
+    static struct {
+	char *value;
+	int flags;
+    } p_wim_info[] = {
+	{ "", 0 },
+#ifdef FEAT_CLPUM
+	{ "popup", WIM_POPUP | WIM_FULL },
+#endif
+	{ "full", WIM_FULL },
+	{ "longest", WIM_LONGEST },
+	{ "longest:full", WIM_LONGEST | WIM_FULL },
+	{ "list", WIM_LIST },
+	{ "list:full", WIM_LIST | WIM_FULL },
+	{ "list:longest", WIM_LIST | WIM_LONGEST },
+	{ NULL, 0 }
+    };
 
     for (i = 0; i < 4; ++i)
 	new_wim_flags[i] = 0;
 
-    for (p = p_wim; *p; ++p)
+    while (*p)
     {
-	for (i = 0; ASCII_ISALPHA(p[i]); ++i)
-	    ;
-	if (p[i] != NUL && p[i] != ',' && p[i] != ':')
-	    return FAIL;
-	if (i == 7 && STRNCMP(p, "longest", 7) == 0)
-	    new_wim_flags[idx] |= WIM_LONGEST;
-	else if (i == 4 && STRNCMP(p, "full", 4) == 0)
-	    new_wim_flags[idx] |= WIM_FULL;
-	else if (i == 4 && STRNCMP(p, "list", 4) == 0)
-	    new_wim_flags[idx] |= WIM_LIST;
-	else
-	    return FAIL;
-	p += i;
-	if (*p == NUL)
-	    break;
-	if (*p == ',')
+	for (i = 0; ; ++i)
 	{
-	    if (idx == 3)
+	    if (p_wim_info[i].value == NULL)	/* p not found in p_wim_info */
 		return FAIL;
-	    ++idx;
+
+	    len = (int)STRLEN(p_wim_info[i].value);
+	    if (STRNCMP(p_wim_info[i].value, p, len) == 0
+		    && (p[len] == ',' || p[len] == NUL))
+	    {
+		new_wim_flags[idx] = p_wim_info[i].flags;
+		if (p[len] == ',')
+		{
+		    if (idx == 3)
+			return FAIL;
+		    ++idx;
+		}
+		p += len + (p[len] == ',');
+		break;		/* check next item in p list */
+	    }
 	}
     }
 
diff --git a/src/option.h b/src/option.h
index 6fba8b8..4627390 100644
--- a/src/option.h
+++ b/src/option.h
@@ -298,6 +298,7 @@
 #define WIM_FULL	1
 #define WIM_LONGEST	2
 #define WIM_LIST	4
+#define WIM_POPUP	8
 
 /* arguments for can_bs() */
 #define BS_INDENT	'i'	/* "Indent" */
@@ -414,6 +415,11 @@ EXTERN long	p_cwh;		/* 'cmdwinheight' */
 #ifdef FEAT_CLIPBOARD
 EXTERN char_u	*p_cb;		/* 'clipboard' */
 #endif
+#ifdef FEAT_CLPUM
+EXTERN char_u	*p_clcfu;	/* 'clcompletefunc' */
+EXTERN char_u	*p_clcot;	/* 'clcompleteopt' */
+EXTERN long	p_clph;		/* 'clpumheight' */
+#endif
 EXTERN long	p_ch;		/* 'cmdheight' */
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 EXTERN int	p_confirm;	/* 'confirm' */
diff --git a/src/proto.h b/src/proto.h
index f4f6476..a4eb26e 100644
--- a/src/proto.h
+++ b/src/proto.h
@@ -64,6 +64,7 @@ extern int _stricoll(char *a, char *b);
 # endif
 # include "buffer.pro"
 # include "charset.pro"
+# include "clpum.pro"
 # ifdef FEAT_CSCOPE
 #  include "if_cscope.pro"
 # endif
diff --git a/src/proto/clpum.pro b/src/proto/clpum.pro
new file mode 100644
index 0000000..41234ef
--- /dev/null
+++ b/src/proto/clpum.pro
@@ -0,0 +1,8 @@
+/* clpum.c */
+void clpum_display(pumitem_T *array, int size, int selected, int disp_col);
+void clpum_redraw(void);
+void clpum_undisplay(void);
+void clpum_clear(void);
+int clpum_visible(void);
+int clpum_get_height(void);
+/* vim: set ft=c : */
diff --git a/src/proto/ex_getln.pro b/src/proto/ex_getln.pro
index 581bfce..eeec651 100644
--- a/src/proto/ex_getln.pro
+++ b/src/proto/ex_getln.pro
@@ -43,6 +43,7 @@ int del_history_entry(int histype, char_u *str);
 int del_history_idx(int histype, int idx);
 void remove_key_from_history(void);
 char_u *get_cmdline_str(void);
+int get_cmdline_len(void);
 int get_cmdline_pos(void);
 int set_cmdline_pos(int pos);
 int get_cmdline_type(void);
@@ -56,4 +57,11 @@ void write_viminfo_history(FILE *fp, int merge);
 void cmd_pchar(int c, int offset);
 int cmd_gchar(int offset);
 char_u *script_get(exarg_T *eap, char_u *cmd);
+int vim_is_clpum_key(int c);
+int clpum_compl_add_infercase(char_u *str, int len, int icase, char_u *fname, int dir, int flags);
+void clpum_completeopt_was_set(void);
+void clpum_compl_show_pum(void);
+int clpum_compl_active(void);
+int clpum_compl_add_tv(typval_T *tv, int dir);
+void clpum_compl_check_keys(int frequency);
 /* vim: set ft=c : */
diff --git a/src/screen.c b/src/screen.c
index 7c4ee30..a920ad0 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -726,6 +726,11 @@ update_screen(int type)
     if (pum_visible())
 	pum_redraw();
 #endif
+#ifdef FEAT_CLPUM
+    /* May need to redraw the command-line popup menu. */
+    if (clpum_visible())
+	clpum_redraw();
+#endif
 
 #ifdef FEAT_WINDOWS
     /* Reset b_mod_set flags.  Going through all windows is probably faster
@@ -6672,6 +6677,11 @@ win_redr_status(win_T *wp)
 	     * drawn over it */
 	    || pum_visible()
 #endif
+#ifdef FEAT_CLPUM
+	    /* don't update status line when command-line popup menu is visible
+	     * and may be drawn over it */
+	    || clpum_visible()
+#endif
 	    )
     {
 	/* Don't redraw right now, do it later. */
@@ -10037,7 +10047,12 @@ showmode(void)
     do_mode = ((p_smd && msg_silent == 0)
 	    && ((State & INSERT)
 		|| restart_edit
-		|| VIsual_active));
+#ifdef FEAT_CLPUM
+		|| (clpum_compl_active()
+		    && p_ch > (get_cmdline_len() + 1) / Columns + 1)
+#endif
+		))
+		|| VIsual_active;
     if (do_mode || Recording)
     {
 	/*
@@ -10095,7 +10110,7 @@ showmode(void)
 		}
 	    }
 #endif
-#ifdef FEAT_INS_EXPAND
+#if defined(FEAT_INS_EXPAND) || defined(FEAT_CLPUM)
 	    /* CTRL-X in Insert mode */
 	    if (edit_submode != NULL && !shortmess(SHM_COMPLETIONMENU))
 	    {
@@ -10567,8 +10582,14 @@ showruler(int always)
 {
     if (!always && !redrawing())
 	return;
+    if (0
 #ifdef FEAT_INS_EXPAND
-    if (pum_visible())
+	    || pum_visible()
+#endif
+#ifdef FEAT_CLPUM
+	    || clpum_visible()
+#endif
+       )
     {
 # ifdef FEAT_WINDOWS
 	/* Don't redraw right now, do it later. */
@@ -10576,7 +10597,7 @@ showruler(int always)
 # endif
 	return;
     }
-#endif
+
 #if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
     if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
     {
@@ -10653,6 +10674,12 @@ win_redr_ruler(win_T *wp, int always)
     if (pum_visible())
 	return;
 #endif
+#ifdef FEAT_CLPUM
+    /* Don't draw the ruler when the command-line popup menu is visible, it may
+     * overlap. */
+    if (clpum_visible())
+	return;
+#endif
 
 #ifdef FEAT_STL_OPT
     if (*p_ruf)
diff --git a/src/syntax.c b/src/syntax.c
index 0face62..82e37b4 100644
--- a/src/syntax.c
+++ b/src/syntax.c
@@ -6805,6 +6805,10 @@ static char *(highlight_init_both[]) =
 	CENT("PmenuSbar ctermbg=Grey",
 	     "PmenuSbar ctermbg=Grey guibg=Grey"),
 #endif
+#ifdef FEAT_CLPUM
+	CENT("ClPmenuSbar ctermbg=Grey",
+	     "ClPmenuSbar ctermbg=Grey guibg=Grey"),
+#endif
 #ifdef FEAT_WINDOWS
 	CENT("TabLineSel term=bold cterm=bold",
 	     "TabLineSel term=bold cterm=bold gui=bold"),
@@ -6850,6 +6854,14 @@ static char *(highlight_init_light[]) =
 	CENT("PmenuSel ctermbg=LightGrey ctermfg=Black",
 	     "PmenuSel ctermbg=LightGrey ctermfg=Black guibg=Grey"),
 #endif
+#ifdef FEAT_CLPUM
+	CENT("ClPmenuThumb ctermbg=Black",
+	     "ClPmenuThumb ctermbg=Black guibg=Black"),
+	CENT("ClPmenu ctermbg=LightGreen ctermfg=Black",
+	     "ClPmenu ctermbg=LightGreen ctermfg=Black guibg=LightGreen"),
+	CENT("ClPmenuSel ctermbg=LightGrey ctermfg=Black",
+	     "ClPmenuSel ctermbg=LightGrey ctermfg=Black guibg=Grey"),
+#endif
 	CENT("SpecialKey term=bold ctermfg=DarkBlue",
 	     "SpecialKey term=bold ctermfg=DarkBlue guifg=Blue"),
 	CENT("Title term=bold ctermfg=DarkMagenta",
@@ -6940,6 +6952,14 @@ static char *(highlight_init_dark[]) =
 	CENT("PmenuSel ctermbg=Black ctermfg=DarkGrey",
 	     "PmenuSel ctermbg=Black ctermfg=DarkGrey guibg=DarkGrey"),
 #endif
+#ifdef FEAT_CLPUM
+	CENT("ClPmenuThumb ctermbg=White",
+	     "ClPmenuThumb ctermbg=White guibg=White"),
+	CENT("ClPmenu ctermbg=Green ctermfg=Black",
+	     "ClPmenu ctermbg=Green ctermfg=Black guibg=Green"),
+	CENT("ClPmenuSel ctermbg=Black ctermfg=DarkGrey",
+	     "ClPmenuSel ctermbg=Black ctermfg=DarkGrey guibg=DarkGrey"),
+#endif
 	CENT("Title term=bold ctermfg=LightMagenta",
 	     "Title term=bold ctermfg=LightMagenta gui=bold guifg=Magenta"),
 	CENT("WarningMsg term=standout ctermfg=LightRed",
diff --git a/src/term.c b/src/term.c
index 7ff5af6..7878fc1 100644
--- a/src/term.c
+++ b/src/term.c
@@ -3063,8 +3063,19 @@ set_shellsize(int width, int height, int mustset)
 #endif
 	    if (State & CMDLINE)
 	    {
-		update_screen(NOT_VALID);
-		redrawcmdline();
+#ifdef FEAT_CLPUM
+		if (clpum_visible())
+		{
+		    redraw_later(NOT_VALID);
+		    clpum_compl_show_pum(); /* This includes the redraw. */
+		    redrawcmdline();
+		}
+		else
+#endif
+		{
+		    update_screen(NOT_VALID);
+		    redrawcmdline();
+		}
 	    }
 	    else
 	    {
diff --git a/src/testdir/Make_all.mak b/src/testdir/Make_all.mak
index 88efd19..87a42fe 100644
--- a/src/testdir/Make_all.mak
+++ b/src/testdir/Make_all.mak
@@ -167,6 +167,7 @@ NEW_TESTS = test_arglist.res \
 	    test_backspace_opt.res \
 	    test_cdo.res \
 	    test_channel.res \
+	    test_clpum.res \
 	    test_cmdline.res \
 	    test_farsi.res \
 	    test_hardcopy.res \
diff --git a/src/testdir/test_clpum.vim b/src/testdir/test_clpum.vim
new file mode 100644
index 0000000..c06037e
--- /dev/null
+++ b/src/testdir/test_clpum.vim
@@ -0,0 +1,11 @@
+" Tests for clpum (command-line popup menu)
+
+if !has('clpum')
+  finish
+endif
+
+function Test_clpum()
+  call assert_equal(0, 0)
+endfunc
+
+" vim: sw=2 et
diff --git a/src/version.c b/src/version.c
index a326ecb..7ecfa87 100644
--- a/src/version.c
+++ b/src/version.c
@@ -126,6 +126,11 @@ static char *(features[]) =
 #else
 	"-clipboard",
 #endif
+#ifdef FEAT_CLPUM
+	"+clpum",
+#else
+	"-clpum",
+#endif
 #ifdef FEAT_CMDL_COMPL
 	"+cmdline_compl",
 #else
diff --git a/src/vim.h b/src/vim.h
index 7d76504..0af2645 100644
--- a/src/vim.h
+++ b/src/vim.h
@@ -1275,6 +1275,7 @@ enum auto_event
     EVENT_BUFWRITEPOST,		/* after writing a buffer */
     EVENT_BUFWRITEPRE,		/* before writing a buffer */
     EVENT_BUFWRITECMD,		/* write buffer using command */
+    EVENT_CLCOMPLETEDONE,	/* after finishing cmdline complete */
     EVENT_CMDWINENTER,		/* after entering the cmdline window */
     EVENT_CMDWINLEAVE,		/* before leaving the cmdline window */
     EVENT_COLORSCHEME,		/* after loading a colorscheme */
@@ -1390,6 +1391,10 @@ typedef enum
     , HLF_PSI	    /* popup menu selected item */
     , HLF_PSB	    /* popup menu scrollbar */
     , HLF_PST	    /* popup menu scrollbar thumb */
+    , HLF_CLPNI	    /* cmd-line popup menu normal item */
+    , HLF_CLPSI	    /* cmd-line popup menu selected item */
+    , HLF_CLPSB	    /* cmd-line popup menu scrollbar */
+    , HLF_CLPST	    /* cmd-line popup menu scrollbar thumb */
     , HLF_TP	    /* tabpage line */
     , HLF_TPS	    /* tabpage line selected */
     , HLF_TPF	    /* tabpage line filler */
@@ -1405,7 +1410,8 @@ typedef enum
 		  'n', 'N', 'r', 's', 'S', 'c', 't', 'v', 'V', 'w', 'W', \
 		  'f', 'F', 'A', 'C', 'D', 'T', '-', '>', \
 		  'B', 'P', 'R', 'L', \
-		  '+', '=', 'x', 'X', '*', '#', '_', '!', '.', 'o'}
+		  '+', '=', 'x', 'X', '0', '1', 'y', 'Y', \
+		  '*', '#', '_', '!', '.', 'o'}
 
 /*
  * Boolean constants
@@ -1973,7 +1979,8 @@ typedef int sock_T;
 #define VV_NONE		68
 #define VV_VIM_DID_ENTER 69
 #define VV_TESTING	70
-#define VV_LEN		71	/* number of v: vars */
+#define VV_CLCOMPLETED_ITEM 71
+#define VV_LEN		72	/* number of v: vars */
 
 /* used for v_number in VAR_SPECIAL */
 #define VVAL_FALSE	0L
